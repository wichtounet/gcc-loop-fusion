Index: doc/invoke.texi
===================================================================
--- doc/invoke.texi	(revision 192214)
+++ doc/invoke.texi	(working copy)
@@ -414,6 +414,7 @@
 -ftree-forwprop -ftree-fre -ftree-loop-if-convert @gol
 -ftree-loop-if-convert-stores -ftree-loop-im @gol
 -ftree-phiprop -ftree-loop-distribution -ftree-loop-distribute-patterns @gol
+-ftree-loop-fusion @gol
 -ftree-loop-ivcanon -ftree-loop-linear -ftree-loop-optimize @gol
 -ftree-parallelize-loops=@var{n} -ftree-pre -ftree-partial-pre -ftree-pta @gol
 -ftree-reassoc -ftree-sink -ftree-slsr -ftree-sra @gol
@@ -7534,6 +7535,9 @@
 @end smallexample
 potentially producing data races.
 
+@item -ftree-loop-fusion
+Perform loop fusion.
+
 @item -ftree-loop-distribution
 Perform loop distribution.  This flag can improve cache performance on
 big loop bodies and allow further loop optimizations, like
Index: tree-pass.h
===================================================================
--- tree-pass.h	(revision 192214)
+++ tree-pass.h	(working copy)
@@ -281,6 +281,7 @@
 extern struct gimple_opt_pass pass_graphite;
 extern struct gimple_opt_pass pass_graphite_transforms;
 extern struct gimple_opt_pass pass_if_conversion;
+extern struct gimple_opt_pass pass_loop_fusion; 
 extern struct gimple_opt_pass pass_loop_distribution;
 extern struct gimple_opt_pass pass_vectorize;
 extern struct gimple_opt_pass pass_slp_vectorize;
Index: tree-loop-fusion.c
===================================================================
--- tree-loop-fusion.c	(revision 0)
+++ tree-loop-fusion.c	(revision 0)
@@ -0,0 +1,920 @@
+/* Loop fusion. */
+
+/* This pass performs loop fusion: for example, the loops
+
+   |loop_1
+   |  A[i] = ...
+   |endloop_1
+
+
+   |loop_2
+   |  ... = A[i]
+   |endloop_2
+
+   that becomes after fusion:
+
+   |loop_1
+   |  A[i] = ...
+   |  ... = A[i]
+   |endloop_1
+
+*/
+
+#include <iostream>
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "ggc.h"
+#include "tree.h"
+#include "target.h"
+
+#include "rtl.h"
+#include "basic-block.h"
+#include "diagnostic.h"
+#include "tree-flow.h"
+#include "tree-dump.h"
+#include "timevar.h"
+#include "cfgloop.h"
+#include "expr.h"
+#include "optabs.h"
+#include "tree-chrec.h"
+#include "tree-data-ref.h"
+#include "tree-scalar-evolution.h"
+#include "tree-pass.h"
+#include "langhooks.h"
+#include "tree-vectorizer.h"
+
+static struct
+{
+  /* The number of loops fused. */
+  int fused;
+
+  /* The number of basic blocks merged during the cleanup pass */
+  int merged;
+
+} fusion_stats;
+
+//TODO Copied from tree-parloops.c, should be put in a common header
+
+/* A transformation matrix, which is a self-contained ROWSIZE x COLSIZE
+   matrix.  Rather than use floats, we simply keep a single DENOMINATOR that
+   represents the denominator for every element in the matrix.  */
+typedef struct lambda_trans_matrix_s
+{
+  lambda_matrix matrix;
+  int rowsize;
+  int colsize;
+  int denominator;
+} *lambda_trans_matrix;
+#define LTM_MATRIX(T) ((T)->matrix)
+#define LTM_ROWSIZE(T) ((T)->rowsize)
+#define LTM_COLSIZE(T) ((T)->colsize)
+#define LTM_DENOMINATOR(T) ((T)->denominator)
+
+/* Allocate a new transformation matrix.  */
+
+static lambda_trans_matrix
+lambda_trans_matrix_new (int colsize, int rowsize,
+			 struct obstack * lambda_obstack)
+{
+  lambda_trans_matrix ret;
+
+  ret = (lambda_trans_matrix)
+    obstack_alloc (lambda_obstack, sizeof (struct lambda_trans_matrix_s));
+  LTM_MATRIX (ret) = lambda_matrix_new (rowsize, colsize, lambda_obstack);
+  LTM_ROWSIZE (ret) = rowsize;
+  LTM_COLSIZE (ret) = colsize;
+  LTM_DENOMINATOR (ret) = 1;
+  return ret;
+}
+
+/* Multiply a vector VEC by a matrix MAT.
+   MAT is an M*N matrix, and VEC is a vector with length N.  The result
+   is stored in DEST which must be a vector of length M.  */
+
+static void
+lambda_matrix_vector_mult (lambda_matrix matrix, int m, int n,
+			   lambda_vector vec, lambda_vector dest)
+{
+  int i, j;
+
+  lambda_vector_clear (dest, m);
+  for (i = 0; i < m; i++)
+    for (j = 0; j < n; j++)
+      dest[i] += matrix[i][j] * vec[j];
+}
+
+/* Return true if TRANS is a legal transformation matrix that respects
+   the dependence vectors in DISTS and DIRS.  The conservative answer
+   is false.
+
+   "Wolfe proves that a unimodular transformation represented by the
+   matrix T is legal when applied to a loop nest with a set of
+   lexicographically non-negative distance vectors RDG if and only if
+   for each vector d in RDG, (T.d >= 0) is lexicographically positive.
+   i.e.: if and only if it transforms the lexicographically positive
+   distance vectors to lexicographically positive vectors.  Note that
+   a unimodular matrix must transform the zero vector (and only it) to
+   the zero vector." S.Muchnick.  */
+
+static bool
+lambda_transform_legal_p (lambda_trans_matrix trans,
+			  int nb_loops,
+			  VEC (ddr_p, heap) *dependence_relations)
+{
+  unsigned int i, j;
+  lambda_vector distres;
+  struct data_dependence_relation *ddr;
+
+  gcc_assert (LTM_COLSIZE (trans) == nb_loops
+	      && LTM_ROWSIZE (trans) == nb_loops);
+
+  /* When there are no dependences, the transformation is correct.  */
+  if (VEC_length (ddr_p, dependence_relations) == 0)
+    return true;
+
+  ddr = VEC_index (ddr_p, dependence_relations, 0);
+  if (ddr == NULL)
+    return true;
+
+  /* When there is an unknown relation in the dependence_relations, we
+     know that it is no worth looking at this loop nest: give up.  */
+  if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)
+    return false;
+
+  distres = lambda_vector_new (nb_loops);
+
+  /* For each distance vector in the dependence graph.  */
+  FOR_EACH_VEC_ELT (ddr_p, dependence_relations, i, ddr)
+    {
+      /* Don't care about relations for which we know that there is no
+	 dependence, nor about read-read (aka. output-dependences):
+	 these data accesses can happen in any order.  */
+      if (DDR_ARE_DEPENDENT (ddr) == chrec_known
+	  || (DR_IS_READ (DDR_A (ddr)) && DR_IS_READ (DDR_B (ddr))))
+	continue;
+
+      /* Conservatively answer: "this transformation is not valid".  */
+      if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)
+	return false;
+
+      /* If the dependence could not be captured by a distance vector,
+	 conservatively answer that the transform is not valid.  */
+      if (DDR_NUM_DIST_VECTS (ddr) == 0)
+	return false;
+
+      /* Compute trans.dist_vect */
+      for (j = 0; j < DDR_NUM_DIST_VECTS (ddr); j++)
+	{
+	  lambda_matrix_vector_mult (LTM_MATRIX (trans), nb_loops, nb_loops,
+				     DDR_DIST_VECT (ddr, j), distres);
+
+	  if (!lambda_vector_lexico_pos (distres, nb_loops))
+	    return false;
+	}
+    }
+  return true;
+}
+
+/* Data dependency analysis. Returns true if the iterations of LOOP
+   are independent on each other (that is, if we can execute them
+   in parallel).  */
+
+static bool
+loop_parallel_p (struct loop *loop, struct obstack * parloop_obstack)
+{
+  VEC (loop_p, heap) *loop_nest;
+  VEC (ddr_p, heap) *dependence_relations;
+  VEC (data_reference_p, heap) *datarefs;
+  lambda_trans_matrix trans;
+  bool ret = false;
+
+  if (dump_file && (dump_flags & TDF_DETAILS))
+  {
+    fprintf (dump_file, "Considering loop %d\n", loop->num);
+    if (!loop->inner)
+      fprintf (dump_file, "loop is innermost\n");
+    else
+      fprintf (dump_file, "loop NOT innermost\n");
+   }
+
+  /* Check for problems with dependences.  If the loop can be reversed,
+     the iterations are independent.  */
+  datarefs = VEC_alloc (data_reference_p, heap, 10);
+  dependence_relations = VEC_alloc (ddr_p, heap, 10 * 10);
+  loop_nest = VEC_alloc (loop_p, heap, 3);
+  if (! compute_data_dependences_for_loop (loop, true, &loop_nest, &datarefs,
+					   &dependence_relations))
+    {
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "  FAILED: cannot analyze data dependencies\n");
+      ret = false;
+      goto end;
+    }
+  if (dump_file && (dump_flags & TDF_DETAILS))
+    dump_data_dependence_relations (dump_file, dependence_relations);
+
+  trans = lambda_trans_matrix_new (1, 1, parloop_obstack);
+  LTM_MATRIX (trans)[0][0] = -1;
+
+  if (lambda_transform_legal_p (trans, 1, dependence_relations))
+    {
+      ret = true;
+      if (dump_file && (dump_flags & TDF_DETAILS))
+	fprintf (dump_file, "  SUCCESS: may be parallelized\n");
+    }
+  else if (dump_file && (dump_flags & TDF_DETAILS))
+    fprintf (dump_file,
+	     "  FAILED: data dependencies exist across iterations\n");
+
+ end:
+  VEC_free (loop_p, heap, loop_nest);
+  free_dependence_relations (dependence_relations);
+  free_data_refs (datarefs);
+
+  return ret;
+}
+
+/* Returns true when a given loop is a sequential loop.  */
+
+static bool
+is_sequential_loop (struct loop *loop, struct obstack * parloop_obstack)
+{
+  if (loop_parallel_p (loop, parloop_obstack))
+    return false;
+  else
+    return true;
+}
+
+/* 
+ * Print the current function to to the dump file 
+ * if logging is enabled. 
+ */
+
+static inline void 
+full_debug(const char* state){
+    if (dump_file && (dump_flags & TDF_DETAILS)){
+        fprintf (dump_file, state);
+        dump_function_to_file(current_function_decl, dump_file, dump_flags);
+    }
+}
+
+/* Return the last BB (last in the instruction stream) */
+
+static basic_block 
+get_last_bb(struct loop *loop){
+    basic_block header = loop->header;
+    basic_block latch = loop->latch;
+
+    if(header->next_bb == latch)
+    {
+       return latch; 
+    } 
+    else 
+    {
+        return header;
+    }
+}
+
+/* Return the first BB (first in the instruction stream) */
+
+static basic_block 
+get_first_bb(struct loop *loop){
+    basic_block header = loop->header;
+    basic_block latch = loop->latch;
+
+    if(header->next_bb == latch)
+    {
+       return header; 
+    } 
+    else 
+    {
+        return latch;
+    }
+}
+
+/* Return the number of basic blocks between the two loops */
+
+static unsigned int
+distance_between_loops (struct loop *loop_a, struct loop *loop_b){
+    //Some loops appears to have their latch first, so taking latch and header
+    //is not enough to determine the distance
+    basic_block current = get_last_bb (loop_b);
+    basic_block header_a = get_first_bb (loop_a);
+
+    unsigned int distance = 0;
+
+    while(current->next_bb != header_a){
+        ++distance;
+        current = current->next_bb;
+    }
+
+    return distance;
+}
+
+/* 
+ * Return the basic block between the two loops. 
+ * Assumes that the distance between the loops is 1. 
+ */
+
+static basic_block
+basic_block_between (struct loop *loop_a, struct loop *loop_b){
+    //Some loops appears to have their latch first, so taking latch and header
+    //is not enough to determine the distance
+    basic_block last_bb = get_last_bb (loop_b);
+
+    return last_bb->next_bb;
+}
+
+/*
+ * Return the number of PHI nodes in the given Basic Block.
+ */
+
+static unsigned int
+gimple_phi_count (basic_block bb){
+    unsigned int count = 0;
+
+    for(gimple_stmt_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi)){
+        ++count;
+    }
+
+    return count;
+}
+
+/*
+ * Return the number of GIMPLE statement in the given Basic Block.
+ */
+
+static unsigned int
+gimple_stmt_count (basic_block bb){
+    unsigned int count = 0;
+
+    for(gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi)){
+        ++count;
+    }
+
+    return count;
+}
+
+/* Return the induction variable SSA name for this loop */
+
+static tree 
+get_ssa_name_iv(struct loop* loop){
+    tree ssa_iv_name = NULL_TREE;
+
+    for(gimple_stmt_iterator gsi = gsi_start_bb (loop->header); !gsi_end_p (gsi); gsi_next (&gsi)){
+        gimple stmt = gsi_stmt (gsi);
+
+        if (gimple_code(stmt) == GIMPLE_COND){
+            tree lhs = gimple_cond_lhs(stmt);
+            tree rhs = gimple_cond_rhs(stmt);
+
+            if(TREE_CODE(lhs) == SSA_NAME){
+                ssa_iv_name = lhs;
+            } else if(TREE_CODE(rhs) == SSA_NAME){
+                ssa_iv_name = rhs;
+            } 
+        }
+    }
+
+    gcc_assert(ssa_iv_name != NULL_TREE);
+
+    return ssa_iv_name;
+}
+
+/* Return the PHI LHS for the given SSA name in the given loop */
+
+static tree 
+get_phi_var_for_iv(struct loop *loop, tree ssa_iv_name){
+    tree def = NULL_TREE;
+    
+    for(gimple_stmt_iterator gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi)){
+        gimple phi = gsi_stmt (gsi);
+        
+        if(SSA_NAME_VAR(gimple_phi_result(phi)) == SSA_NAME_VAR(ssa_iv_name)){
+            def = gimple_phi_result(phi);
+            break;
+        }
+    }
+    
+    gcc_assert(def != NULL_TREE);
+
+    return def;
+}
+
+/* 
+ * This function fuses two loops together 
+ *
+ * The two functions have to be mergeable and mergeable together before this function is called. 
+ */
+
+static void
+fuse_loops (struct loop* loop_a, struct loop* loop_b){
+    if (dump_file && (dump_flags & TDF_DETAILS)){
+        fprintf (dump_file, "Fusion of A=%d and B=%d\n", loop_a->num, loop_b->num);
+        full_debug("Before fusion\n");
+        flow_loops_dump(dump_file, NULL, 10);
+    }
+
+    /* 1. Replace the induction variable */
+
+    tree ssa_iv_name_b = get_ssa_name_iv(loop_b);
+    tree ssa_iv_name_a = get_ssa_name_iv(loop_a);
+    
+    tree use = get_phi_var_for_iv(loop_b, ssa_iv_name_b);
+    tree def = get_phi_var_for_iv(loop_a, ssa_iv_name_a);
+    
+    replace_uses_by (def, use);
+    
+    full_debug("After IV replacing\n");
+
+    /* 2. Transfer other PHI nodes */
+
+    edge old_entry_edge = loop_preheader_edge (loop_a);
+    edge old_latch_edge = loop_latch_edge (loop_a);
+    
+    edge new_entry_edge = loop_preheader_edge (loop_b);
+    edge new_latch_edge = loop_latch_edge (loop_b);
+    
+    for(gimple_stmt_iterator gsi = gsi_start_phis (loop_a->header); !gsi_end_p (gsi); ){
+        gimple phi_orig = gsi_stmt (gsi);
+        
+        if(SSA_NAME_VAR(gimple_phi_result(phi_orig)) != SSA_NAME_VAR(ssa_iv_name_a)){
+            fprintf (dump_file, "Found a PHI node to copy \n");
+
+            tree res = gimple_phi_result(phi_orig);
+            gimple phi_new = create_phi_node(res, loop_b->header);
+        
+            tree def;
+            source_location locus;
+
+            /* Copy the first PHI arg (coming from entry) */
+            def = PHI_ARG_DEF_FROM_EDGE (phi_orig, old_entry_edge);
+            locus = gimple_phi_arg_location_from_edge (phi_orig, old_entry_edge);
+            add_phi_arg (phi_new, def, new_entry_edge, locus);
+            
+            /* Copy the second PHI arg (coming from the latch) */
+            def = PHI_ARG_DEF_FROM_EDGE (phi_orig, old_latch_edge);
+            locus = gimple_phi_arg_location_from_edge (phi_orig, old_latch_edge);
+            add_phi_arg (phi_new, def, new_latch_edge, locus);
+
+            //We do not want the SSA name to be released
+            remove_phi_node (&gsi, false);
+        } else {
+            //The SSA name can be released
+            remove_phi_node (&gsi, true);
+        }
+    }
+    
+    full_debug("After transfer of PHI nodes\n");
+
+    /* 3. Transfer all the statements */
+    
+    gimple_stmt_iterator gsi_b_last = gsi_last_bb (loop_b->header);
+    gsi_prev (&gsi_b_last);
+
+    for (gimple_stmt_iterator gsi = gsi_start_bb (loop_a->header); !gsi_end_p (gsi);)
+    {
+        gimple stmt = gsi_stmt(gsi);
+
+        if (is_gimple_assign(stmt) && gimple_assign_rhs_code(stmt) != COND_EXPR && gimple_assign_rhs_code(stmt) != LABEL_EXPR)
+        {
+            update_stmt (stmt);
+            gsi_move_before (&gsi, &gsi_b_last);
+            update_stmt (stmt);
+        }
+        else
+        {
+            gsi_next (&gsi);
+        }
+    }
+    
+    full_debug("After transfer of statements\n");
+
+    /* 5. Delete the loop A */
+    
+    //Save them before loop gets deleted
+    basic_block header_b = loop_b->header;
+    basic_block between_bb = basic_block_between (loop_a, loop_b);
+    basic_block bb6 = loop_a->header;
+    basic_block bb7 = loop_a->latch;
+    basic_block next_bb = get_last_bb (loop_a)->next_bb;
+    
+    //Move bb6 and bb7 in the outer loop
+    remove_bb_from_loops (bb6);
+    add_bb_to_loop (bb6, loop_outer (loop_b));
+    
+    remove_bb_from_loops (bb7);
+    add_bb_to_loop (bb7, loop_outer (loop_b));
+    
+    delete_loop(loop_a);
+        
+    delete_basic_block(bb7);
+        
+    full_debug("After removing the loop\n");
+
+    /* 6. Fix edges */
+
+    //Fix the type of the edge
+    EDGE_SUCC(bb6, 0)->flags |= EDGE_FALLTHRU;
+    EDGE_SUCC(bb6, 0)->flags &= ~EDGE_TRUE_VALUE;
+    EDGE_SUCC(bb6, 0)->flags &= ~EDGE_FALSE_VALUE;
+    
+    //Remove the condition from the old loop header
+    for (gimple_stmt_iterator gsi = gsi_start_bb (bb6); !gsi_end_p (gsi);)
+    {
+        gimple stmt = gsi_stmt(gsi);
+
+        if (gimple_code(stmt) == GIMPLE_COND)
+        {
+            gsi_remove(&gsi, true);
+        }
+        else
+        {
+            gsi_next (&gsi);
+        }
+    }
+    
+    full_debug("After fixing the edges \n");
+
+    /* 7. Clean the basic blocks */
+
+    //Remove the between block if possible
+    if(gimple_seq_empty_p (phi_nodes (between_bb)) && gimple_seq_empty_p (bb_seq (between_bb))){
+        redirect_edge_and_branch (EDGE_SUCC (loop_b->header, 1), bb6);
+
+        delete_basic_block (between_bb);
+    } else {
+        set_immediate_dominator (CDI_DOMINATORS, between_bb, recompute_dominator (CDI_DOMINATORS, between_bb));
+    }
+    
+    full_debug("After cleaning basic blocks\n");
+
+    /* 7. Update SSA */
+
+    update_ssa(TODO_update_ssa);
+
+    /* 8. Update dominators */
+    
+    set_immediate_dominator (CDI_DOMINATORS, loop_b->header, recompute_dominator (CDI_DOMINATORS, loop_b->header));
+    set_immediate_dominator (CDI_DOMINATORS, loop_b->latch, recompute_dominator (CDI_DOMINATORS, loop_b->latch));
+    set_immediate_dominator (CDI_DOMINATORS, next_bb, recompute_dominator (CDI_DOMINATORS, next_bb));
+    set_immediate_dominator (CDI_DOMINATORS, bb6, recompute_dominator (CDI_DOMINATORS, bb6));
+    
+    full_debug("After fusion\n");
+
+    ++fusion_stats.fused;
+}
+
+/* Indicates if the specified basic block would profit from a merge */
+
+static bool
+dirty(basic_block bb){
+    if(gimple_seq_empty_p (bb_seq (bb)) && gimple_seq_empty_p (phi_nodes (bb))){
+        return single_succ_p (bb) && single_pred_p (bb);
+    }
+
+    return false;
+}
+
+/* Tries to find basic blocks to be merged */
+
+static void
+cleanup(){
+    basic_block bb;
+    
+    FOR_EACH_BB(bb){
+        if(dirty(bb)){
+            basic_block bb_next = bb->next_bb;
+
+            if(bb_next && dirty (bb_next)){
+                //They have to fall through the instruction stream
+                if(single_succ_edge (bb)->dest == bb_next){
+                    merge_blocks(bb, bb_next);
+                    
+                    ++fusion_stats.merged;
+                }
+            }
+        }
+    }
+}
+
+/* Print a debug message if logging is enabled */
+
+static inline void
+print (const char* message){
+    if (dump_file && (dump_flags & TDF_DETAILS)){
+        fprintf (dump_file, message);
+    }
+}
+
+/* Returns true if loops are independent. */
+
+static bool
+are_independent (struct loop *loop_a, struct loop *loop_b){
+  VEC (data_reference_p, heap) *datarefs_a = VEC_alloc (data_reference_p, heap, 10);
+  VEC (data_reference_p, heap) *datarefs_b = VEC_alloc (data_reference_p, heap, 10);
+
+  VEC (ddr_p, heap) *dependence_relations_a = VEC_alloc (ddr_p, heap, 10 * 10);
+  VEC (ddr_p, heap) *dependence_relations_b = VEC_alloc (ddr_p, heap, 10 * 10);
+  
+  VEC (loop_p, heap) *loop_nest_a = VEC_alloc (loop_p, heap, 3);
+  VEC (loop_p, heap) *loop_nest_b = VEC_alloc (loop_p, heap, 3);
+
+  compute_data_dependences_for_loop (loop_a, true, &loop_nest_a, &datarefs_a, &dependence_relations_a); 
+  compute_data_dependences_for_loop (loop_b, true, &loop_nest_b, &datarefs_b, &dependence_relations_b);
+  
+  if (dump_file && (dump_flags & TDF_DETAILS)){
+      data_reference_p dataref_a;
+      data_reference_p dataref_b;
+      unsigned int i;
+
+      fprintf (dump_file, "dumping data references of a \n");
+      FOR_EACH_VEC_ELT(data_reference_p, datarefs_a, i, dataref_a){
+          dump_data_reference(dump_file, dataref_a);
+      }
+      
+      fprintf (dump_file, "dumping data references of b \n");
+      FOR_EACH_VEC_ELT(data_reference_p, datarefs_b, i, dataref_b){
+          dump_data_reference(dump_file, dataref_b);
+      }
+  }
+      
+  data_reference_p dataref_first;
+  data_reference_p dataref_second;
+  unsigned int i;
+  unsigned int j;
+      
+  //If no dependences are found later, the loops are not dependent
+  bool ret = true;
+
+  //Consider each pair of dependences between the loops
+  FOR_EACH_VEC_ELT(data_reference_p, datarefs_b, i, dataref_first){
+      FOR_EACH_VEC_ELT(data_reference_p, datarefs_a, j, dataref_second){
+
+          if(same_data_refs_base_objects(dataref_first, dataref_second)){
+              if(DR_IS_READ(dataref_first) && DR_IS_READ(dataref_second)){
+                  print ("Found an input-dependence\n");
+                  //Input reference can be ignored
+              } else if(DR_IS_WRITE(dataref_first) && DR_IS_WRITE(dataref_second)){
+                  print ("Found an output-dependence\n");
+
+                  if(!same_data_refs (dataref_first, dataref_second)){
+                      print ("An output-dependence is blocking\n");
+                      ret = false;
+                  }
+              } else if(DR_IS_READ(dataref_first) && DR_IS_WRITE(dataref_second)){
+                  print ("Found an anti-dependence\n");
+
+                  if(!same_data_refs (dataref_first, dataref_second)){
+                      print ("An anti-dependence is blocking\n");
+                      ret = false;
+                  }
+              } else if(DR_IS_WRITE(dataref_first) && DR_IS_READ(dataref_second)){
+                  print ("Found a true-dependence\n");
+
+                  if(!same_data_refs (dataref_first, dataref_second)){
+                      print ("A true-dependence is blocking\n");
+                      ret = false;
+                  }
+              }
+          }
+      }
+  }
+
+  free_dependence_relations (dependence_relations_a);
+  free_dependence_relations (dependence_relations_b);
+  
+  free_data_refs (datarefs_a);
+  free_data_refs (datarefs_b);
+  
+  VEC_free (loop_p, heap, loop_nest_a);
+  VEC_free (loop_p, heap, loop_nest_b);
+
+  return ret;
+}
+
+/* Verify if this loop is supported by the merging algorithm */
+
+static bool 
+loop_is_mergeable(struct loop* loop){
+    //The algorithm will fail on loop with more than one exit
+    if (!single_exit(loop)){
+        return false; 
+    }
+
+    //It is necessary to know the number of times a loop will iterate
+    if(!loop->any_estimate || !loop->any_upper_bound){
+        return false;
+    }
+    
+    //It is necessary to have a precise estimate
+    if(loop->nb_iterations_estimate != loop->nb_iterations_upper_bound){
+        return false;
+    }
+     
+    //The algorithm only supports loops with a header and a latch
+    if (loop->num_nodes > 2){
+        return false;
+    }
+
+    return true;
+}
+
+static bool
+loops_are_mergeable(struct loop *loop_a, struct loop *loop_b){
+    //Both loop should iterate the same number of times
+    if(loop_a->nb_iterations_estimate != loop_b->nb_iterations_estimate){
+        return false;
+    }
+
+    //Only support loops with only one basic block between them
+    unsigned int distance = distance_between_loops (loop_a, loop_b);
+    if(distance != 1){
+        if (dump_file && (dump_flags & TDF_DETAILS)){
+            fprintf (dump_file, "The distance is too high (distance=%d)\n", distance);
+        }
+
+        return false;
+    }
+
+    basic_block between_bb = basic_block_between (loop_a, loop_b);
+
+    //Only empty block between A and B are supported
+    if(!gimple_seq_empty_p( bb_seq( between_bb))){
+        if (dump_file && (dump_flags & TDF_DETAILS)){
+            fprintf (dump_file, "Too many statements in the between block\n");
+        }
+
+        return false;
+    }
+
+    //Only empty block between A and B are supported
+    if(!gimple_seq_empty_p( phi_nodes( between_bb))){
+        if (dump_file && (dump_flags & TDF_DETAILS)){
+            fprintf (dump_file, "Too many PHI nodes in the between block\n");
+        }
+
+        return false;
+    }
+
+    //If all the other conditions, the loops needs only to be independent to be fused
+    return are_independent (loop_a, loop_b);
+}
+
+/* Return true if the two loops are interesting to merge, otherwise return false.  */
+
+static bool
+loops_are_interesting_to_merge(struct loop *loop_a, struct loop *loop_b){
+    //TODO
+    return true;
+}
+
+/* Performs legal loops fusion in the current function.  */
+
+static unsigned int
+tree_loop_fusion (void)
+{
+    //If there are no loops, no need to go farther
+    if (!current_loops){
+        return 0;
+    }
+    
+    //Initialize the stats
+    memset (&fusion_stats, 0, sizeof (fusion_stats));
+   
+    if (dump_file && (dump_flags & TDF_DETAILS)){
+        int num_loops = number_of_loops();
+        fprintf (dump_file, "Start loop fusion pass (%d loops)\n", num_loops);
+
+        flow_loops_dump(dump_file, NULL, 10);
+    }
+
+    struct loop *loop;
+    loop_iterator li;
+
+    //Consider only innermost loops, other cannot be merged with this strategy
+    FOR_EACH_LOOP (li, loop, LI_ONLY_INNERMOST)
+    {
+        //The algorithm cannot merge all loops
+        if(!loop_is_mergeable(loop)){
+            if (dump_file && (dump_flags & TDF_DETAILS)){
+                fprintf (dump_file, "Loop %d cannot be merged\n", loop->num);
+            }
+
+            continue;
+        }
+
+        //Loop->next points to a loop in the same loop tree
+        if (loop->next)
+        {
+            struct loop *next = loop->next;
+
+            gcc_assert(loop_outer(loop) == loop_outer(next));
+
+            //The algorithm cannot merge all loops
+            if(!loop_is_mergeable(next)){
+                if (dump_file && (dump_flags & TDF_DETAILS)){
+                    fprintf (dump_file, "Loop %d cannot be merged\n", next->num);
+                }
+
+                continue;
+            }
+                
+            if (dump_file && (dump_flags & TDF_DETAILS)){
+                fprintf (dump_file, "Consider Loops %d and %d as candidates\n", loop->num, next->num);
+            }
+
+            //Verify that the loops can be merged together
+            if(!loops_are_mergeable (loop, next)){
+                if (dump_file && (dump_flags & TDF_DETAILS)){
+                    fprintf (dump_file, "Loops %d and %d cannot be merged\n", loop->num, next->num);
+                }
+
+                continue;
+            }
+                
+            //Finally, if they are interesting to merge, merge them
+            if(loops_are_interesting_to_merge (loop, next)){
+                fuse_loops (loop, next);
+
+                //The cleanup remove empty basic blocks to make further loop fusion possible
+                cleanup();
+            }
+        }
+    }
+    
+    //Update and verify the function is loops were fused
+    if(fusion_stats.fused > 0){
+        //The merging strategy does not take virtual operands into account
+        mark_virtual_operands_for_renaming (cfun);
+
+        //Make sure the function is transformed in LCSSA
+        rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);
+
+        //Update if necessary
+        update_ssa(TODO_update_ssa);
+
+        //Activate verification of the whole function
+        #ifdef ENABLE_CHECKING
+            verify_loop_structure();
+            verify_gimple_in_cfg(cfun);
+            verify_ssa(true);
+        #endif
+    }
+  
+    //Add events for this pass 
+    statistics_counter_event (cfun, "Loop Fused", fusion_stats.fused);
+    statistics_counter_event (cfun, "Basic Blocks Merged", fusion_stats.merged);
+
+    /* struct graph *original_graph_1 = new_graph (num_loops);
+       original_graph_1 = create_original_graph (num_loops);
+       dump_graph (dump_file, original_graph_1);
+       dump_graph (stderr, original_graph_1);
+       fprintf (dump_file, "printed the original_graph\n\n"); 
+       fprintf (stderr, "printed the original_graph\n\n");
+       struct graph *component_graph_parallel = create_component_graph ('P', num_loops);
+       dump_graph (dump_file, component_graph_parallel);
+       dump_graph (stderr, component_graph_parallel);
+       fprintf (dump_file, "printed the component parallel graph\n\n"); 
+       fprintf (stderr, "printed the component parallel graph\n\n");
+       dump_graph (dump_file, original_graph_1);
+       dump_graph (stderr, original_graph_1);
+       fprintf (dump_file, "printed the original_graph\n\n"); 
+       fprintf (stderr, "printed the original_graph\n\n");
+       do_partitions (component_graph_parallel);
+       dump_graph (dump_file, component_graph_parallel);
+       dump_graph (stderr, component_graph_parallel);
+       fprintf (dump_file, "printed the partitioned component parallel graph\n"); 
+       fprintf (stderr, "printed the partitioned component parallel graph\n");
+       fuse_according_to_graph (component_graph_parallel);*/
+
+    return 0;
+}
+
+static bool
+gate_tree_loop_fusion (void)
+{
+    return flag_tree_loop_fusion != 0;
+}
+
+struct gimple_opt_pass pass_loop_fusion =
+{
+    {
+        GIMPLE_PASS, 
+        "lfusion",                      /* name */
+        gate_tree_loop_fusion,          /* gate */
+        tree_loop_fusion,               /* execute */
+        NULL,                           /* sub */
+        NULL,                           /* next */
+        0,                              /* static_pass_number */
+        TV_TREE_LOOP_FUSION,            /* tv_id */
+        PROP_cfg | PROP_ssa,            /* properties_required */
+        0,                              /* properties_provided */
+        0,                              /* properties_destroyed */
+        0,                              /* todo_flags_start */
+        TODO_update_ssa | TODO_verify_ssa,   /* todo_flags_finish */
+    }
+};
Index: timevar.def
===================================================================
--- timevar.def	(revision 192214)
+++ timevar.def	(working copy)
@@ -171,6 +171,7 @@
 DEFTIMEVAR (TV_GRAPHITE_TRANSFORMS   , "Graphite loop transforms")
 DEFTIMEVAR (TV_GRAPHITE_DATA_DEPS    , "Graphite data dep analysis")
 DEFTIMEVAR (TV_GRAPHITE_CODE_GEN     , "Graphite code generation")
+DEFTIMEVAR (TV_TREE_LOOP_FUSION      , "tree loop fusion")
 DEFTIMEVAR (TV_TREE_LOOP_DISTRIBUTION, "tree loop distribution")
 DEFTIMEVAR (TV_CHECK_DATA_DEPS       , "tree check data dependences")
 DEFTIMEVAR (TV_TREE_PREFETCH	     , "tree prefetching")
Index: common.opt
===================================================================
--- common.opt	(revision 192214)
+++ common.opt	(working copy)
@@ -2050,6 +2050,10 @@
 Common Report Var(flag_optimize_strlen) Optimization
 Enable string length optimizations on trees
 
+ftree-loop-fusion
+Common Report Var(flag_tree_loop_fusion) Optimization
+Enable loop fusion on trees
+
 ftree-loop-distribution
 Common Report Var(flag_tree_loop_distribution) Optimization
 Enable loop distribution on trees
Index: Makefile.in
===================================================================
--- Makefile.in	(revision 192214)
+++ Makefile.in	(working copy)
@@ -1356,6 +1356,7 @@
 	tree-inline.o \
 	tree-into-ssa.o \
 	tree-iterator.o \
+    tree-loop-fusion.o \
 	tree-loop-distribution.o \
 	tree-nested.o \
 	tree-nomudflap.o \
@@ -2578,6 +2579,11 @@
    dumpfile.h $(TM_H) $(GGC_H) $(TREE_H) $(TREE_FLOW_H) \
    $(CFGLOOP_H) $(TREE_PASS_H) $(TREE_VECTORIZER_H) \
    $(TREE_PRETTY_PRINT_H)
+tree-loop-fusion.o: tree-loop-fusion.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \
+   $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \
+   tree-pass.h $(TREE_DATA_REF_H) $(SCEV_H) $(EXPR_H) \
+   $(TARGET_H) tree-chrec.h tree-vectorizer.h
 tree-loop-distribution.o: tree-loop-distribution.c $(CONFIG_H) $(SYSTEM_H) \
    coretypes.h $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) $(TREE_PASS_H)
 tree-parloops.o: tree-parloops.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
Index: passes.c
===================================================================
--- passes.c	(revision 192214)
+++ passes.c	(working copy)
@@ -1450,6 +1450,7 @@
 	  NEXT_PASS (pass_scev_cprop);
 	  NEXT_PASS (pass_record_bounds);
 	  NEXT_PASS (pass_check_data_deps);
+     NEXT_PASS (pass_loop_fusion);
 	  NEXT_PASS (pass_loop_distribution);
 	  NEXT_PASS (pass_copy_prop);
 	  NEXT_PASS (pass_graphite);

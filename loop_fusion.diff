Index: gcc/doc/invoke.texi
===================================================================
--- gcc/doc/invoke.texi	(revision 192574)
+++ gcc/doc/invoke.texi	(working copy)
@@ -414,6 +414,7 @@
 -ftree-forwprop -ftree-fre -ftree-loop-if-convert @gol
 -ftree-loop-if-convert-stores -ftree-loop-im @gol
 -ftree-phiprop -ftree-loop-distribution -ftree-loop-distribute-patterns @gol
+-ftree-loop-fusion @gol
 -ftree-loop-ivcanon -ftree-loop-linear -ftree-loop-optimize @gol
 -ftree-parallelize-loops=@var{n} -ftree-pre -ftree-partial-pre -ftree-pta @gol
 -ftree-reassoc -ftree-sink -ftree-slsr -ftree-sra @gol
@@ -6418,6 +6419,7 @@
 -fstrict-aliasing -fstrict-overflow @gol
 -ftree-switch-conversion -ftree-tail-merge @gol
 -ftree-pre @gol
+-ftree-loop-fusion @gol
 -ftree-vrp}
 
 Please note the warning under @option{-fgcse} about
@@ -7534,6 +7536,11 @@
 @end smallexample
 potentially producing data races.
 
+@item -ftree-loop-fusion
+Perform loop fusion. This flag can improve cache performance on loops
+iterating through the same arrays.
+Enabled at level @option{-O2} and higher.
+
 @item -ftree-loop-distribution
 Perform loop distribution.  This flag can improve cache performance on
 big loop bodies and allow further loop optimizations, like
Index: gcc/tree-ssa-loop-manip.c
===================================================================
--- gcc/tree-ssa-loop-manip.c	(revision 192574)
+++ gcc/tree-ssa-loop-manip.c	(working copy)
@@ -363,127 +363,127 @@
   basic_block def_bb;
   struct loop *def_loop;
 
-  if (TREE_CODE (use) != SSA_NAME)
+    if (TREE_CODE (use) != SSA_NAME)
     return;
 
-  ver = SSA_NAME_VERSION (use);
-  def_bb = gimple_bb (SSA_NAME_DEF_STMT (use));
-  if (!def_bb)
+    ver = SSA_NAME_VERSION (use);
+    def_bb = gimple_bb (SSA_NAME_DEF_STMT (use));
+    if (!def_bb)
     return;
-  def_loop = def_bb->loop_father;
+    def_loop = def_bb->loop_father;
 
-  /* If the definition is not inside a loop, it is not interesting.  */
-  if (!loop_outer (def_loop))
+    /* If the definition is not inside a loop, it is not interesting.  */
+    if (!loop_outer (def_loop))
     return;
 
-  /* If the use is not outside of the loop it is defined in, it is not
+    /* If the use is not outside of the loop it is defined in, it is not
      interesting.  */
-  if (flow_bb_inside_loop_p (def_loop, bb))
+    if (flow_bb_inside_loop_p (def_loop, bb))
     return;
 
-  /* If we're seeing VER for the first time, we still have to allocate
+    /* If we're seeing VER for the first time, we still have to allocate
      a bitmap for its uses.  */
-  if (bitmap_set_bit (need_phis, ver))
+    if (bitmap_set_bit (need_phis, ver))
     use_blocks[ver] = BITMAP_ALLOC (&loop_renamer_obstack);
-  bitmap_set_bit (use_blocks[ver], bb->index);
-}
+    bitmap_set_bit (use_blocks[ver], bb->index);
+    }
 
-/* For uses in STMT, mark names that are used outside of the loop they are
-   defined to rewrite.  Record the set of blocks in that the ssa
-   names are defined to USE_BLOCKS and the ssa names themselves to
-   NEED_PHIS.  */
+    /* For uses in STMT, mark names that are used outside of the loop they are
+    defined to rewrite.  Record the set of blocks in that the ssa
+    names are defined to USE_BLOCKS and the ssa names themselves to
+    NEED_PHIS.  */
 
-static void
-find_uses_to_rename_stmt (gimple stmt, bitmap *use_blocks, bitmap need_phis)
-{
-  ssa_op_iter iter;
-  tree var;
-  basic_block bb = gimple_bb (stmt);
+    static void
+    find_uses_to_rename_stmt (gimple stmt, bitmap *use_blocks, bitmap need_phis)
+    {
+    ssa_op_iter iter;
+    tree var;
+    basic_block bb = gimple_bb (stmt);
 
-  if (is_gimple_debug (stmt))
+    if (is_gimple_debug (stmt))
     return;
 
-  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_USES)
+    FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_ALL_USES)
     find_uses_to_rename_use (bb, var, use_blocks, need_phis);
-}
+    }
 
-/* Marks names that are used in BB and outside of the loop they are
-   defined in for rewrite.  Records the set of blocks in that the ssa
-   names are defined to USE_BLOCKS.  Record the SSA names that will
-   need exit PHIs in NEED_PHIS.  */
+    /* Marks names that are used in BB and outside of the loop they are
+    defined in for rewrite.  Records the set of blocks in that the ssa
+    names are defined to USE_BLOCKS.  Record the SSA names that will
+    need exit PHIs in NEED_PHIS.  */
 
-static void
-find_uses_to_rename_bb (basic_block bb, bitmap *use_blocks, bitmap need_phis)
-{
-  gimple_stmt_iterator bsi;
-  edge e;
-  edge_iterator ei;
+    static void
+    find_uses_to_rename_bb (basic_block bb, bitmap *use_blocks, bitmap need_phis)
+    {
+    gimple_stmt_iterator bsi;
+    edge e;
+    edge_iterator ei;
 
-  FOR_EACH_EDGE (e, ei, bb->succs)
+    FOR_EACH_EDGE (e, ei, bb->succs)
     for (bsi = gsi_start_phis (e->dest); !gsi_end_p (bsi); gsi_next (&bsi))
       {
         gimple phi = gsi_stmt (bsi);
-	find_uses_to_rename_use (bb, PHI_ARG_DEF_FROM_EDGE (phi, e),
-				 use_blocks, need_phis);
+    find_uses_to_rename_use (bb, PHI_ARG_DEF_FROM_EDGE (phi, e),
+                 use_blocks, need_phis);
       }
 
-  for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))
+    for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))
     find_uses_to_rename_stmt (gsi_stmt (bsi), use_blocks, need_phis);
-}
+    }
 
-/* Marks names that are used outside of the loop they are defined in
-   for rewrite.  Records the set of blocks in that the ssa
-   names are defined to USE_BLOCKS.  If CHANGED_BBS is not NULL,
-   scan only blocks in this set.  */
+    /* Marks names that are used outside of the loop they are defined in
+    for rewrite.  Records the set of blocks in that the ssa
+    names are defined to USE_BLOCKS.  If CHANGED_BBS is not NULL,
+    scan only blocks in this set.  */
 
-static void
-find_uses_to_rename (bitmap changed_bbs, bitmap *use_blocks, bitmap need_phis)
-{
-  basic_block bb;
-  unsigned index;
-  bitmap_iterator bi;
+    static void
+    find_uses_to_rename (bitmap changed_bbs, bitmap *use_blocks, bitmap need_phis)
+    {
+    basic_block bb;
+    unsigned index;
+    bitmap_iterator bi;
 
-  /* ??? If CHANGED_BBS is empty we rewrite the whole function -- why?  */
-  if (changed_bbs && !bitmap_empty_p (changed_bbs))
+    /* ??? If CHANGED_BBS is empty we rewrite the whole function -- why?  */
+    if (changed_bbs && !bitmap_empty_p (changed_bbs))
     {
       EXECUTE_IF_SET_IN_BITMAP (changed_bbs, 0, index, bi)
-	{
-	  find_uses_to_rename_bb (BASIC_BLOCK (index), use_blocks, need_phis);
-	}
+    {
+      find_uses_to_rename_bb (BASIC_BLOCK (index), use_blocks, need_phis);
     }
-  else
+    }
+    else
     {
       FOR_EACH_BB (bb)
-	{
-	  find_uses_to_rename_bb (bb, use_blocks, need_phis);
-	}
+    {
+      find_uses_to_rename_bb (bb, use_blocks, need_phis);
     }
-}
+    }
+    }
 
-/* Rewrites the program into a loop closed ssa form -- i.e. inserts extra
-   phi nodes to ensure that no variable is used outside the loop it is
-   defined in.
+    /* Rewrites the program into a loop closed ssa form -- i.e. inserts extra
+    phi nodes to ensure that no variable is used outside the loop it is
+    defined in.
 
-   This strengthening of the basic ssa form has several advantages:
+    This strengthening of the basic ssa form has several advantages:
 
-   1) Updating it during unrolling/peeling/versioning is trivial, since
+    1) Updating it during unrolling/peeling/versioning is trivial, since
       we do not need to care about the uses outside of the loop.
       The same applies to virtual operands which are also rewritten into
       loop closed SSA form.  Note that virtual operands are always live
       until function exit.
-   2) The behavior of all uses of an induction variable is the same.
+    2) The behavior of all uses of an induction variable is the same.
       Without this, you need to distinguish the case when the variable
       is used outside of the loop it is defined in, for example
 
       for (i = 0; i < 100; i++)
-	{
-	  for (j = 0; j < 100; j++)
-	    {
-	      k = i + j;
-	      use1 (k);
-	    }
-	  use2 (k);
-	}
+    {
+      for (j = 0; j < 100; j++)
+        {
+          k = i + j;
+          use1 (k);
+        }
+      use2 (k);
+    }
 
       Looking from the outer loop with the normal SSA form, the first use of k
       is not well-behaved, while the second one is an induction variable with
@@ -495,135 +495,135 @@
       UPDATE_FLAG is used in the call to update_ssa.  See
       TODO_update_ssa* for documentation.  */
 
-void
-rewrite_into_loop_closed_ssa (bitmap changed_bbs, unsigned update_flag)
-{
-  bitmap *loop_exits;
-  bitmap *use_blocks;
-  bitmap names_to_rename;
+    void
+    rewrite_into_loop_closed_ssa (bitmap changed_bbs, unsigned update_flag)
+    {
+    bitmap *loop_exits;
+    bitmap *use_blocks;
+    bitmap names_to_rename;
 
-  loops_state_set (LOOP_CLOSED_SSA);
-  if (number_of_loops () <= 1)
+    loops_state_set (LOOP_CLOSED_SSA);
+    if (number_of_loops () <= 1)
     return;
 
-  /* If the pass has caused the SSA form to be out-of-date, update it
+    /* If the pass has caused the SSA form to be out-of-date, update it
      now.  */
-  update_ssa (update_flag);
+    update_ssa (update_flag);
 
-  bitmap_obstack_initialize (&loop_renamer_obstack);
+    bitmap_obstack_initialize (&loop_renamer_obstack);
 
-  names_to_rename = BITMAP_ALLOC (&loop_renamer_obstack);
+    names_to_rename = BITMAP_ALLOC (&loop_renamer_obstack);
 
-  /* An array of bitmaps where LOOP_EXITS[I] is the set of basic blocks
+    /* An array of bitmaps where LOOP_EXITS[I] is the set of basic blocks
      that are the destination of an edge exiting loop number I.  */
-  loop_exits = XNEWVEC (bitmap, number_of_loops ());
-  get_loops_exits (loop_exits);
+    loop_exits = XNEWVEC (bitmap, number_of_loops ());
+    get_loops_exits (loop_exits);
 
-  /* Uses of names to rename.  We don't have to initialize this array,
+    /* Uses of names to rename.  We don't have to initialize this array,
      because we know that we will only have entries for the SSA names
      in NAMES_TO_RENAME.  */
-  use_blocks = XNEWVEC (bitmap, num_ssa_names);
+    use_blocks = XNEWVEC (bitmap, num_ssa_names);
 
-  /* Find the uses outside loops.  */
-  find_uses_to_rename (changed_bbs, use_blocks, names_to_rename);
+    /* Find the uses outside loops.  */
+    find_uses_to_rename (changed_bbs, use_blocks, names_to_rename);
 
-  /* Add the PHI nodes on exits of the loops for the names we need to
+    /* Add the PHI nodes on exits of the loops for the names we need to
      rewrite.  */
-  add_exit_phis (names_to_rename, use_blocks, loop_exits);
+    add_exit_phis (names_to_rename, use_blocks, loop_exits);
 
-  bitmap_obstack_release (&loop_renamer_obstack);
-  free (use_blocks);
-  free (loop_exits);
+    bitmap_obstack_release (&loop_renamer_obstack);
+    free (use_blocks);
+    free (loop_exits);
 
-  /* Fix up all the names found to be used outside their original
+    /* Fix up all the names found to be used outside their original
      loops.  */
-  update_ssa (TODO_update_ssa);
-}
+    update_ssa (TODO_update_ssa);
+    }
 
-/* Check invariants of the loop closed ssa form for the USE in BB.  */
+    /* Check invariants of the loop closed ssa form for the USE in BB.  */
 
-static void
-check_loop_closed_ssa_use (basic_block bb, tree use)
-{
-  gimple def;
-  basic_block def_bb;
+    static void
+    check_loop_closed_ssa_use (basic_block bb, tree use)
+    {
+    gimple def;
+    basic_block def_bb;
 
-  if (TREE_CODE (use) != SSA_NAME || virtual_operand_p (use))
+    if (TREE_CODE (use) != SSA_NAME || virtual_operand_p (use))
     return;
 
-  def = SSA_NAME_DEF_STMT (use);
-  def_bb = gimple_bb (def);
-  gcc_assert (!def_bb
-	      || flow_bb_inside_loop_p (def_bb->loop_father, bb));
-}
+    def = SSA_NAME_DEF_STMT (use);
+    def_bb = gimple_bb (def);
+    gcc_assert (!def_bb
+          || flow_bb_inside_loop_p (def_bb->loop_father, bb));
+    }
 
-/* Checks invariants of loop closed ssa form in statement STMT in BB.  */
+    /* Checks invariants of loop closed ssa form in statement STMT in BB.  */
 
-static void
-check_loop_closed_ssa_stmt (basic_block bb, gimple stmt)
-{
-  ssa_op_iter iter;
-  tree var;
+    static void
+    check_loop_closed_ssa_stmt (basic_block bb, gimple stmt)
+    {
+    ssa_op_iter iter;
+    tree var;
 
-  if (is_gimple_debug (stmt))
+    if (is_gimple_debug (stmt))
     return;
 
-  FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_USE)
+    FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_USE)
     check_loop_closed_ssa_use (bb, var);
-}
+    }
 
-/* Checks that invariants of the loop closed ssa form are preserved.
-   Call verify_ssa when VERIFY_SSA_P is true.  */
+    /* Checks that invariants of the loop closed ssa form are preserved.
+    Call verify_ssa when VERIFY_SSA_P is true.  */
 
-DEBUG_FUNCTION void
-verify_loop_closed_ssa (bool verify_ssa_p)
-{
-  basic_block bb;
-  gimple_stmt_iterator bsi;
-  gimple phi;
-  edge e;
-  edge_iterator ei;
+    DEBUG_FUNCTION void
+    verify_loop_closed_ssa (bool verify_ssa_p)
+    {
+    basic_block bb;
+    gimple_stmt_iterator bsi;
+    gimple phi;
+    edge e;
+    edge_iterator ei;
 
-  if (number_of_loops () <= 1)
+    if (number_of_loops () <= 1)
     return;
 
-  if (verify_ssa_p)
+    if (verify_ssa_p)
     verify_ssa (false);
 
-  timevar_push (TV_VERIFY_LOOP_CLOSED);
+    timevar_push (TV_VERIFY_LOOP_CLOSED);
 
-  FOR_EACH_BB (bb)
+    FOR_EACH_BB (bb)
     {
       for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))
-	{
-	  phi = gsi_stmt (bsi);
-	  FOR_EACH_EDGE (e, ei, bb->preds)
-	    check_loop_closed_ssa_use (e->src,
-				       PHI_ARG_DEF_FROM_EDGE (phi, e));
-	}
+    {
+      phi = gsi_stmt (bsi);
+      FOR_EACH_EDGE (e, ei, bb->preds)
+        check_loop_closed_ssa_use (e->src,
+                       PHI_ARG_DEF_FROM_EDGE (phi, e));
+    }
 
       for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))
-	check_loop_closed_ssa_stmt (bb, gsi_stmt (bsi));
+    check_loop_closed_ssa_stmt (bb, gsi_stmt (bsi));
     }
 
-  timevar_pop (TV_VERIFY_LOOP_CLOSED);
-}
+    timevar_pop (TV_VERIFY_LOOP_CLOSED);
+    }
 
-/* Split loop exit edge EXIT.  The things are a bit complicated by a need to
-   preserve the loop closed ssa form.  The newly created block is returned.  */
+    /* Split loop exit edge EXIT.  The things are a bit complicated by a need to
+    preserve the loop closed ssa form.  The newly created block is returned.  */
 
-basic_block
-split_loop_exit_edge (edge exit)
-{
-  basic_block dest = exit->dest;
-  basic_block bb = split_edge (exit);
-  gimple phi, new_phi;
-  tree new_name, name;
-  use_operand_p op_p;
-  gimple_stmt_iterator psi;
-  source_location locus;
+    basic_block
+    split_loop_exit_edge (edge exit)
+    {
+    basic_block dest = exit->dest;
+    basic_block bb = split_edge (exit);
+    gimple phi, new_phi;
+    tree new_name, name;
+    use_operand_p op_p;
+    gimple_stmt_iterator psi;
+    source_location locus;
 
-  for (psi = gsi_start_phis (dest); !gsi_end_p (psi); gsi_next (&psi))
+    for (psi = gsi_start_phis (dest); !gsi_end_p (psi); gsi_next (&psi))
     {
       phi = gsi_stmt (psi);
       op_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, single_succ_edge (bb));
@@ -632,338 +632,338 @@
       name = USE_FROM_PTR (op_p);
 
       /* If the argument of the PHI node is a constant, we do not need
-	 to keep it inside loop.  */
+     to keep it inside loop.  */
       if (TREE_CODE (name) != SSA_NAME)
-	continue;
+    continue;
 
       /* Otherwise create an auxiliary phi node that will copy the value
-	 of the SSA name out of the loop.  */
+     of the SSA name out of the loop.  */
       new_name = duplicate_ssa_name (name, NULL);
       new_phi = create_phi_node (new_name, bb);
       add_phi_arg (new_phi, name, exit, locus);
       SET_USE (op_p, new_name);
     }
 
-  return bb;
-}
+    return bb;
+    }
 
-/* Returns the basic block in that statements should be emitted for induction
-   variables incremented at the end of the LOOP.  */
+    /* Returns the basic block in that statements should be emitted for induction
+    variables incremented at the end of the LOOP.  */
 
-basic_block
-ip_end_pos (struct loop *loop)
-{
-  return loop->latch;
-}
+    basic_block
+    ip_end_pos (struct loop *loop)
+    {
+    return loop->latch;
+    }
 
-/* Returns the basic block in that statements should be emitted for induction
-   variables incremented just before exit condition of a LOOP.  */
+    /* Returns the basic block in that statements should be emitted for induction
+    variables incremented just before exit condition of a LOOP.  */
 
-basic_block
-ip_normal_pos (struct loop *loop)
-{
-  gimple last;
-  basic_block bb;
-  edge exit;
+    basic_block
+    ip_normal_pos (struct loop *loop)
+    {
+    gimple last;
+    basic_block bb;
+    edge exit;
 
-  if (!single_pred_p (loop->latch))
+    if (!single_pred_p (loop->latch))
     return NULL;
 
-  bb = single_pred (loop->latch);
-  last = last_stmt (bb);
-  if (!last
+    bb = single_pred (loop->latch);
+    last = last_stmt (bb);
+    if (!last
       || gimple_code (last) != GIMPLE_COND)
     return NULL;
 
-  exit = EDGE_SUCC (bb, 0);
-  if (exit->dest == loop->latch)
+    exit = EDGE_SUCC (bb, 0);
+    if (exit->dest == loop->latch)
     exit = EDGE_SUCC (bb, 1);
 
-  if (flow_bb_inside_loop_p (loop, exit->dest))
+    if (flow_bb_inside_loop_p (loop, exit->dest))
     return NULL;
 
-  return bb;
-}
+    return bb;
+    }
 
-/* Stores the standard position for induction variable increment in LOOP
-   (just before the exit condition if it is available and latch block is empty,
-   end of the latch block otherwise) to BSI.  INSERT_AFTER is set to true if
-   the increment should be inserted after *BSI.  */
+    /* Stores the standard position for induction variable increment in LOOP
+    (just before the exit condition if it is available and latch block is empty,
+    end of the latch block otherwise) to BSI.  INSERT_AFTER is set to true if
+    the increment should be inserted after *BSI.  */
 
-void
-standard_iv_increment_position (struct loop *loop, gimple_stmt_iterator *bsi,
-				bool *insert_after)
-{
-  basic_block bb = ip_normal_pos (loop), latch = ip_end_pos (loop);
-  gimple last = last_stmt (latch);
+    void
+    standard_iv_increment_position (struct loop *loop, gimple_stmt_iterator *bsi,
+                bool *insert_after)
+    {
+    basic_block bb = ip_normal_pos (loop), latch = ip_end_pos (loop);
+    gimple last = last_stmt (latch);
 
-  if (!bb
+    if (!bb
       || (last && gimple_code (last) != GIMPLE_LABEL))
     {
       *bsi = gsi_last_bb (latch);
       *insert_after = true;
     }
-  else
+    else
     {
       *bsi = gsi_last_bb (bb);
       *insert_after = false;
     }
-}
+    }
 
-/* Copies phi node arguments for duplicated blocks.  The index of the first
-   duplicated block is FIRST_NEW_BLOCK.  */
+    /* Copies phi node arguments for duplicated blocks.  The index of the first
+    duplicated block is FIRST_NEW_BLOCK.  */
 
-static void
-copy_phi_node_args (unsigned first_new_block)
-{
-  unsigned i;
+    static void
+    copy_phi_node_args (unsigned first_new_block)
+    {
+    unsigned i;
 
-  for (i = first_new_block; i < (unsigned) last_basic_block; i++)
+    for (i = first_new_block; i < (unsigned) last_basic_block; i++)
     BASIC_BLOCK (i)->flags |= BB_DUPLICATED;
 
-  for (i = first_new_block; i < (unsigned) last_basic_block; i++)
+    for (i = first_new_block; i < (unsigned) last_basic_block; i++)
     add_phi_args_after_copy_bb (BASIC_BLOCK (i));
 
-  for (i = first_new_block; i < (unsigned) last_basic_block; i++)
+    for (i = first_new_block; i < (unsigned) last_basic_block; i++)
     BASIC_BLOCK (i)->flags &= ~BB_DUPLICATED;
-}
+    }
 
 
-/* The same as cfgloopmanip.c:duplicate_loop_to_header_edge, but also
-   updates the PHI nodes at start of the copied region.  In order to
-   achieve this, only loops whose exits all lead to the same location
-   are handled.
+    /* The same as cfgloopmanip.c:duplicate_loop_to_header_edge, but also
+    updates the PHI nodes at start of the copied region.  In order to
+    achieve this, only loops whose exits all lead to the same location
+    are handled.
 
-   Notice that we do not completely update the SSA web after
-   duplication.  The caller is responsible for calling update_ssa
-   after the loop has been duplicated.  */
+    Notice that we do not completely update the SSA web after
+    duplication.  The caller is responsible for calling update_ssa
+    after the loop has been duplicated.  */
 
-bool
-gimple_duplicate_loop_to_header_edge (struct loop *loop, edge e,
-				    unsigned int ndupl, sbitmap wont_exit,
-				    edge orig, VEC (edge, heap) **to_remove,
-				    int flags)
-{
-  unsigned first_new_block;
+    bool
+    gimple_duplicate_loop_to_header_edge (struct loop *loop, edge e,
+                    unsigned int ndupl, sbitmap wont_exit,
+                    edge orig, VEC (edge, heap) **to_remove,
+                    int flags)
+    {
+    unsigned first_new_block;
 
-  if (!loops_state_satisfies_p (LOOPS_HAVE_SIMPLE_LATCHES))
+    if (!loops_state_satisfies_p (LOOPS_HAVE_SIMPLE_LATCHES))
     return false;
-  if (!loops_state_satisfies_p (LOOPS_HAVE_PREHEADERS))
+    if (!loops_state_satisfies_p (LOOPS_HAVE_PREHEADERS))
     return false;
 
 #ifdef ENABLE_CHECKING
-  /* ???  This forces needless update_ssa calls after processing each
+    /* ???  This forces needless update_ssa calls after processing each
      loop instead of just once after processing all loops.  We should
      instead verify that loop-closed SSA form is up-to-date for LOOP
      only (and possibly SSA form).  For now just skip verifying if
      there are to-be renamed variables.  */
-  if (!need_ssa_update_p (cfun)
+    if (!need_ssa_update_p (cfun)
       && loops_state_satisfies_p (LOOP_CLOSED_SSA))
     verify_loop_closed_ssa (true);
 #endif
 
-  first_new_block = last_basic_block;
-  if (!duplicate_loop_to_header_edge (loop, e, ndupl, wont_exit,
-				      orig, to_remove, flags))
+    first_new_block = last_basic_block;
+    if (!duplicate_loop_to_header_edge (loop, e, ndupl, wont_exit,
+                      orig, to_remove, flags))
     return false;
 
-  /* Readd the removed phi args for e.  */
-  flush_pending_stmts (e);
+    /* Readd the removed phi args for e.  */
+    flush_pending_stmts (e);
 
-  /* Copy the phi node arguments.  */
-  copy_phi_node_args (first_new_block);
+    /* Copy the phi node arguments.  */
+    copy_phi_node_args (first_new_block);
 
-  scev_reset ();
+    scev_reset ();
 
-  return true;
-}
+    return true;
+    }
 
-/* Returns true if we can unroll LOOP FACTOR times.  Number
-   of iterations of the loop is returned in NITER.  */
+    /* Returns true if we can unroll LOOP FACTOR times.  Number
+    of iterations of the loop is returned in NITER.  */
 
-bool
-can_unroll_loop_p (struct loop *loop, unsigned factor,
-		   struct tree_niter_desc *niter)
-{
-  edge exit;
+    bool
+    can_unroll_loop_p (struct loop *loop, unsigned factor,
+           struct tree_niter_desc *niter)
+    {
+    edge exit;
 
-  /* Check whether unrolling is possible.  We only want to unroll loops
+    /* Check whether unrolling is possible.  We only want to unroll loops
      for that we are able to determine number of iterations.  We also
      want to split the extra iterations of the loop from its end,
      therefore we require that the loop has precisely one
      exit.  */
 
-  exit = single_dom_exit (loop);
-  if (!exit)
+    exit = single_dom_exit (loop);
+    if (!exit)
     return false;
 
-  if (!number_of_iterations_exit (loop, exit, niter, false)
+    if (!number_of_iterations_exit (loop, exit, niter, false)
       || niter->cmp == ERROR_MARK
       /* Scalar evolutions analysis might have copy propagated
-	 the abnormal ssa names into these expressions, hence
-	 emitting the computations based on them during loop
-	 unrolling might create overlapping life ranges for
-	 them, and failures in out-of-ssa.  */
+     the abnormal ssa names into these expressions, hence
+     emitting the computations based on them during loop
+     unrolling might create overlapping life ranges for
+     them, and failures in out-of-ssa.  */
       || contains_abnormal_ssa_name_p (niter->may_be_zero)
       || contains_abnormal_ssa_name_p (niter->control.base)
       || contains_abnormal_ssa_name_p (niter->control.step)
       || contains_abnormal_ssa_name_p (niter->bound))
     return false;
 
-  /* And of course, we must be able to duplicate the loop.  */
-  if (!can_duplicate_loop_p (loop))
+    /* And of course, we must be able to duplicate the loop.  */
+    if (!can_duplicate_loop_p (loop))
     return false;
 
-  /* The final loop should be small enough.  */
-  if (tree_num_loop_insns (loop, &eni_size_weights) * factor
+    /* The final loop should be small enough.  */
+    if (tree_num_loop_insns (loop, &eni_size_weights) * factor
       > (unsigned) PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS))
     return false;
 
-  return true;
-}
+    return true;
+    }
 
-/* Determines the conditions that control execution of LOOP unrolled FACTOR
-   times.  DESC is number of iterations of LOOP.  ENTER_COND is set to
-   condition that must be true if the main loop can be entered.
-   EXIT_BASE, EXIT_STEP, EXIT_CMP and EXIT_BOUND are set to values describing
-   how the exit from the unrolled loop should be controlled.  */
+    /* Determines the conditions that control execution of LOOP unrolled FACTOR
+    times.  DESC is number of iterations of LOOP.  ENTER_COND is set to
+    condition that must be true if the main loop can be entered.
+    EXIT_BASE, EXIT_STEP, EXIT_CMP and EXIT_BOUND are set to values describing
+    how the exit from the unrolled loop should be controlled.  */
 
-static void
-determine_exit_conditions (struct loop *loop, struct tree_niter_desc *desc,
-			   unsigned factor, tree *enter_cond,
-			   tree *exit_base, tree *exit_step,
-			   enum tree_code *exit_cmp, tree *exit_bound)
-{
-  gimple_seq stmts;
-  tree base = desc->control.base;
-  tree step = desc->control.step;
-  tree bound = desc->bound;
-  tree type = TREE_TYPE (step);
-  tree bigstep, delta;
-  tree min = lower_bound_in_type (type, type);
-  tree max = upper_bound_in_type (type, type);
-  enum tree_code cmp = desc->cmp;
-  tree cond = boolean_true_node, assum;
+    static void
+    determine_exit_conditions (struct loop *loop, struct tree_niter_desc *desc,
+               unsigned factor, tree *enter_cond,
+               tree *exit_base, tree *exit_step,
+               enum tree_code *exit_cmp, tree *exit_bound)
+    {
+    gimple_seq stmts;
+    tree base = desc->control.base;
+    tree step = desc->control.step;
+    tree bound = desc->bound;
+    tree type = TREE_TYPE (step);
+    tree bigstep, delta;
+    tree min = lower_bound_in_type (type, type);
+    tree max = upper_bound_in_type (type, type);
+    enum tree_code cmp = desc->cmp;
+    tree cond = boolean_true_node, assum;
 
-  /* For pointers, do the arithmetics in the type of step.  */
-  base = fold_convert (type, base);
-  bound = fold_convert (type, bound);
+    /* For pointers, do the arithmetics in the type of step.  */
+    base = fold_convert (type, base);
+    bound = fold_convert (type, bound);
 
-  *enter_cond = boolean_false_node;
-  *exit_base = NULL_TREE;
-  *exit_step = NULL_TREE;
-  *exit_cmp = ERROR_MARK;
-  *exit_bound = NULL_TREE;
-  gcc_assert (cmp != ERROR_MARK);
+    *enter_cond = boolean_false_node;
+    *exit_base = NULL_TREE;
+    *exit_step = NULL_TREE;
+    *exit_cmp = ERROR_MARK;
+    *exit_bound = NULL_TREE;
+    gcc_assert (cmp != ERROR_MARK);
 
-  /* We only need to be correct when we answer question
+    /* We only need to be correct when we answer question
      "Do at least FACTOR more iterations remain?" in the unrolled loop.
      Thus, transforming BASE + STEP * i <> BOUND to
      BASE + STEP * i < BOUND is ok.  */
-  if (cmp == NE_EXPR)
+    if (cmp == NE_EXPR)
     {
       if (tree_int_cst_sign_bit (step))
-	cmp = GT_EXPR;
+    cmp = GT_EXPR;
       else
-	cmp = LT_EXPR;
+    cmp = LT_EXPR;
     }
-  else if (cmp == LT_EXPR)
+    else if (cmp == LT_EXPR)
     {
       gcc_assert (!tree_int_cst_sign_bit (step));
     }
-  else if (cmp == GT_EXPR)
+    else if (cmp == GT_EXPR)
     {
       gcc_assert (tree_int_cst_sign_bit (step));
     }
-  else
+    else
     gcc_unreachable ();
 
-  /* The main body of the loop may be entered iff:
+    /* The main body of the loop may be entered iff:
 
      1) desc->may_be_zero is false.
      2) it is possible to check that there are at least FACTOR iterations
-	of the loop, i.e., BOUND - step * FACTOR does not overflow.
+    of the loop, i.e., BOUND - step * FACTOR does not overflow.
      3) # of iterations is at least FACTOR  */
 
-  if (!integer_zerop (desc->may_be_zero))
+    if (!integer_zerop (desc->may_be_zero))
     cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,
-			invert_truthvalue (desc->may_be_zero),
-			cond);
+            invert_truthvalue (desc->may_be_zero),
+            cond);
 
-  bigstep = fold_build2 (MULT_EXPR, type, step,
-			 build_int_cst_type (type, factor));
-  delta = fold_build2 (MINUS_EXPR, type, bigstep, step);
-  if (cmp == LT_EXPR)
+    bigstep = fold_build2 (MULT_EXPR, type, step,
+             build_int_cst_type (type, factor));
+    delta = fold_build2 (MINUS_EXPR, type, bigstep, step);
+    if (cmp == LT_EXPR)
     assum = fold_build2 (GE_EXPR, boolean_type_node,
-			 bound,
-			 fold_build2 (PLUS_EXPR, type, min, delta));
-  else
+             bound,
+             fold_build2 (PLUS_EXPR, type, min, delta));
+    else
     assum = fold_build2 (LE_EXPR, boolean_type_node,
-			 bound,
-			 fold_build2 (PLUS_EXPR, type, max, delta));
-  cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, assum, cond);
+             bound,
+             fold_build2 (PLUS_EXPR, type, max, delta));
+    cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, assum, cond);
 
-  bound = fold_build2 (MINUS_EXPR, type, bound, delta);
-  assum = fold_build2 (cmp, boolean_type_node, base, bound);
-  cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, assum, cond);
+    bound = fold_build2 (MINUS_EXPR, type, bound, delta);
+    assum = fold_build2 (cmp, boolean_type_node, base, bound);
+    cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, assum, cond);
 
-  cond = force_gimple_operand (unshare_expr (cond), &stmts, false, NULL_TREE);
-  if (stmts)
+    cond = force_gimple_operand (unshare_expr (cond), &stmts, false, NULL_TREE);
+    if (stmts)
     gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);
-  /* cond now may be a gimple comparison, which would be OK, but also any
+    /* cond now may be a gimple comparison, which would be OK, but also any
      other gimple rhs (say a && b).  In this case we need to force it to
      operand.  */
-  if (!is_gimple_condexpr (cond))
+    if (!is_gimple_condexpr (cond))
     {
       cond = force_gimple_operand (cond, &stmts, true, NULL_TREE);
       if (stmts)
-	gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);
+    gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);
     }
-  *enter_cond = cond;
+    *enter_cond = cond;
 
-  base = force_gimple_operand (unshare_expr (base), &stmts, true, NULL_TREE);
-  if (stmts)
+    base = force_gimple_operand (unshare_expr (base), &stmts, true, NULL_TREE);
+    if (stmts)
     gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);
-  bound = force_gimple_operand (unshare_expr (bound), &stmts, true, NULL_TREE);
-  if (stmts)
+    bound = force_gimple_operand (unshare_expr (bound), &stmts, true, NULL_TREE);
+    if (stmts)
     gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);
 
-  *exit_base = base;
-  *exit_step = bigstep;
-  *exit_cmp = cmp;
-  *exit_bound = bound;
-}
+    *exit_base = base;
+    *exit_step = bigstep;
+    *exit_cmp = cmp;
+    *exit_bound = bound;
+    }
 
-/* Scales the frequencies of all basic blocks in LOOP that are strictly
-   dominated by BB by NUM/DEN.  */
+    /* Scales the frequencies of all basic blocks in LOOP that are strictly
+    dominated by BB by NUM/DEN.  */
 
-static void
-scale_dominated_blocks_in_loop (struct loop *loop, basic_block bb,
-				int num, int den)
-{
-  basic_block son;
+    static void
+    scale_dominated_blocks_in_loop (struct loop *loop, basic_block bb,
+                int num, int den)
+    {
+    basic_block son;
 
-  if (den == 0)
+    if (den == 0)
     return;
 
-  for (son = first_dom_son (CDI_DOMINATORS, bb);
+    for (son = first_dom_son (CDI_DOMINATORS, bb);
        son;
        son = next_dom_son (CDI_DOMINATORS, son))
     {
       if (!flow_bb_inside_loop_p (loop, son))
-	continue;
+    continue;
       scale_bbs_frequencies_int (&son, 1, num, den);
       scale_dominated_blocks_in_loop (loop, son, num, den);
     }
-}
+    }
 
-/* Unroll LOOP FACTOR times.  DESC describes number of iterations of LOOP.
-   EXIT is the exit of the loop to that DESC corresponds.
+    /* Unroll LOOP FACTOR times.  DESC describes number of iterations of LOOP.
+    EXIT is the exit of the loop to that DESC corresponds.
 
-   If N is number of iterations of the loop and MAY_BE_ZERO is the condition
-   under that loop exits in the first iteration even if N != 0,
+    If N is number of iterations of the loop and MAY_BE_ZERO is the condition
+    under that loop exits in the first iteration even if N != 0,
 
-   while (1)
+    while (1)
      {
        x = phi (init, next);
 
@@ -973,13 +973,13 @@
        post;
      }
 
-   becomes (with possibly the exit conditions formulated a bit differently,
-   avoiding the need to create a new iv):
+    becomes (with possibly the exit conditions formulated a bit differently,
+    avoiding the need to create a new iv):
 
-   if (MAY_BE_ZERO || N < FACTOR)
+    if (MAY_BE_ZERO || N < FACTOR)
      goto rest;
 
-   do
+    do
      {
        x = phi (init, next);
 
@@ -994,10 +994,10 @@
 
      } while (N >= FACTOR);
 
-   rest:
+    rest:
      init' = phi (init, x);
 
-   while (1)
+    while (1)
      {
        x = phi (init', next);
 
@@ -1007,51 +1007,51 @@
        post;
      }
 
-   Before the loop is unrolled, TRANSFORM is called for it (only for the
-   unrolled loop, but not for its versioned copy).  DATA is passed to
-   TRANSFORM.  */
+    Before the loop is unrolled, TRANSFORM is called for it (only for the
+    unrolled loop, but not for its versioned copy).  DATA is passed to
+    TRANSFORM.  */
 
-/* Probability in % that the unrolled loop is entered.  Just a guess.  */
+    /* Probability in % that the unrolled loop is entered.  Just a guess.  */
 #define PROB_UNROLLED_LOOP_ENTERED 90
 
-void
-tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,
-				edge exit, struct tree_niter_desc *desc,
-				transform_callback transform,
-				void *data)
-{
-  gimple exit_if;
-  tree ctr_before, ctr_after;
-  tree enter_main_cond, exit_base, exit_step, exit_bound;
-  enum tree_code exit_cmp;
-  gimple phi_old_loop, phi_new_loop, phi_rest;
-  gimple_stmt_iterator psi_old_loop, psi_new_loop;
-  tree init, next, new_init;
-  struct loop *new_loop;
-  basic_block rest, exit_bb;
-  edge old_entry, new_entry, old_latch, precond_edge, new_exit;
-  edge new_nonexit, e;
-  gimple_stmt_iterator bsi;
-  use_operand_p op;
-  bool ok;
-  unsigned est_niter, prob_entry, scale_unrolled, scale_rest, freq_e, freq_h;
-  unsigned new_est_niter, i, prob;
-  unsigned irr = loop_preheader_edge (loop)->flags & EDGE_IRREDUCIBLE_LOOP;
-  sbitmap wont_exit;
-  VEC (edge, heap) *to_remove = NULL;
+    void
+    tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,
+                edge exit, struct tree_niter_desc *desc,
+                transform_callback transform,
+                void *data)
+    {
+    gimple exit_if;
+    tree ctr_before, ctr_after;
+    tree enter_main_cond, exit_base, exit_step, exit_bound;
+    enum tree_code exit_cmp;
+    gimple phi_old_loop, phi_new_loop, phi_rest;
+    gimple_stmt_iterator psi_old_loop, psi_new_loop;
+    tree init, next, new_init;
+    struct loop *new_loop;
+    basic_block rest, exit_bb;
+    edge old_entry, new_entry, old_latch, precond_edge, new_exit;
+    edge new_nonexit, e;
+    gimple_stmt_iterator bsi;
+    use_operand_p op;
+    bool ok;
+    unsigned est_niter, prob_entry, scale_unrolled, scale_rest, freq_e, freq_h;
+    unsigned new_est_niter, i, prob;
+    unsigned irr = loop_preheader_edge (loop)->flags & EDGE_IRREDUCIBLE_LOOP;
+    sbitmap wont_exit;
+    VEC (edge, heap) *to_remove = NULL;
 
-  est_niter = expected_loop_iterations (loop);
-  determine_exit_conditions (loop, desc, factor,
-			     &enter_main_cond, &exit_base, &exit_step,
-			     &exit_cmp, &exit_bound);
+    est_niter = expected_loop_iterations (loop);
+    determine_exit_conditions (loop, desc, factor,
+                 &enter_main_cond, &exit_base, &exit_step,
+                 &exit_cmp, &exit_bound);
 
-  /* Let us assume that the unrolled loop is quite likely to be entered.  */
-  if (integer_nonzerop (enter_main_cond))
+    /* Let us assume that the unrolled loop is quite likely to be entered.  */
+    if (integer_nonzerop (enter_main_cond))
     prob_entry = REG_BR_PROB_BASE;
-  else
+    else
     prob_entry = PROB_UNROLLED_LOOP_ENTERED * REG_BR_PROB_BASE / 100;
 
-  /* The values for scales should keep profile consistent, and somewhat close
+    /* The values for scales should keep profile consistent, and somewhat close
      to correct.
 
      TODO: The current value of SCALE_REST makes it appear that the loop that
@@ -1063,71 +1063,71 @@
      loop, and recompute the distribution of frequencies in its body because
      of this change (scale the frequencies of blocks before and after the exit
      by appropriate factors).  */
-  scale_unrolled = prob_entry;
-  scale_rest = REG_BR_PROB_BASE;
+    scale_unrolled = prob_entry;
+    scale_rest = REG_BR_PROB_BASE;
 
-  new_loop = loop_version (loop, enter_main_cond, NULL,
-			   prob_entry, scale_unrolled, scale_rest, true);
-  gcc_assert (new_loop != NULL);
-  update_ssa (TODO_update_ssa);
+    new_loop = loop_version (loop, enter_main_cond, NULL,
+               prob_entry, scale_unrolled, scale_rest, true);
+    gcc_assert (new_loop != NULL);
+    update_ssa (TODO_update_ssa);
 
-  /* Determine the probability of the exit edge of the unrolled loop.  */
-  new_est_niter = est_niter / factor;
+    /* Determine the probability of the exit edge of the unrolled loop.  */
+    new_est_niter = est_niter / factor;
 
-  /* Without profile feedback, loops for that we do not know a better estimate
+    /* Without profile feedback, loops for that we do not know a better estimate
      are assumed to roll 10 times.  When we unroll such loop, it appears to
      roll too little, and it may even seem to be cold.  To avoid this, we
      ensure that the created loop appears to roll at least 5 times (but at
      most as many times as before unrolling).  */
-  if (new_est_niter < 5)
+    if (new_est_niter < 5)
     {
       if (est_niter < 5)
-	new_est_niter = est_niter;
+    new_est_niter = est_niter;
       else
-	new_est_niter = 5;
+    new_est_niter = 5;
     }
 
-  /* Prepare the cfg and update the phi nodes.  Move the loop exit to the
+    /* Prepare the cfg and update the phi nodes.  Move the loop exit to the
      loop latch (and make its condition dummy, for the moment).  */
-  rest = loop_preheader_edge (new_loop)->src;
-  precond_edge = single_pred_edge (rest);
-  split_edge (loop_latch_edge (loop));
-  exit_bb = single_pred (loop->latch);
+    rest = loop_preheader_edge (new_loop)->src;
+    precond_edge = single_pred_edge (rest);
+    split_edge (loop_latch_edge (loop));
+    exit_bb = single_pred (loop->latch);
 
-  /* Since the exit edge will be removed, the frequency of all the blocks
+    /* Since the exit edge will be removed, the frequency of all the blocks
      in the loop that are dominated by it must be scaled by
      1 / (1 - exit->probability).  */
-  scale_dominated_blocks_in_loop (loop, exit->src,
-				  REG_BR_PROB_BASE,
-				  REG_BR_PROB_BASE - exit->probability);
+    scale_dominated_blocks_in_loop (loop, exit->src,
+                  REG_BR_PROB_BASE,
+                  REG_BR_PROB_BASE - exit->probability);
 
-  bsi = gsi_last_bb (exit_bb);
-  exit_if = gimple_build_cond (EQ_EXPR, integer_zero_node,
-			       integer_zero_node,
-			       NULL_TREE, NULL_TREE);
+    bsi = gsi_last_bb (exit_bb);
+    exit_if = gimple_build_cond (EQ_EXPR, integer_zero_node,
+                   integer_zero_node,
+                   NULL_TREE, NULL_TREE);
 
-  gsi_insert_after (&bsi, exit_if, GSI_NEW_STMT);
-  new_exit = make_edge (exit_bb, rest, EDGE_FALSE_VALUE | irr);
-  rescan_loop_exit (new_exit, true, false);
+    gsi_insert_after (&bsi, exit_if, GSI_NEW_STMT);
+    new_exit = make_edge (exit_bb, rest, EDGE_FALSE_VALUE | irr);
+    rescan_loop_exit (new_exit, true, false);
 
-  /* Set the probability of new exit to the same of the old one.  Fix
+    /* Set the probability of new exit to the same of the old one.  Fix
      the frequency of the latch block, by scaling it back by
      1 - exit->probability.  */
-  new_exit->count = exit->count;
-  new_exit->probability = exit->probability;
-  new_nonexit = single_pred_edge (loop->latch);
-  new_nonexit->probability = REG_BR_PROB_BASE - exit->probability;
-  new_nonexit->flags = EDGE_TRUE_VALUE;
-  new_nonexit->count -= exit->count;
-  if (new_nonexit->count < 0)
+    new_exit->count = exit->count;
+    new_exit->probability = exit->probability;
+    new_nonexit = single_pred_edge (loop->latch);
+    new_nonexit->probability = REG_BR_PROB_BASE - exit->probability;
+    new_nonexit->flags = EDGE_TRUE_VALUE;
+    new_nonexit->count -= exit->count;
+    if (new_nonexit->count < 0)
     new_nonexit->count = 0;
-  scale_bbs_frequencies_int (&loop->latch, 1, new_nonexit->probability,
-			     REG_BR_PROB_BASE);
+    scale_bbs_frequencies_int (&loop->latch, 1, new_nonexit->probability,
+                 REG_BR_PROB_BASE);
 
-  old_entry = loop_preheader_edge (loop);
-  new_entry = loop_preheader_edge (new_loop);
-  old_latch = loop_latch_edge (loop);
-  for (psi_old_loop = gsi_start_phis (loop->header),
+    old_entry = loop_preheader_edge (loop);
+    new_entry = loop_preheader_edge (new_loop);
+    old_latch = loop_latch_edge (loop);
+    for (psi_old_loop = gsi_start_phis (loop->header),
        psi_new_loop = gsi_start_phis (new_loop->header);
        !gsi_end_p (psi_old_loop);
        gsi_next (&psi_old_loop), gsi_next (&psi_new_loop))
@@ -1141,20 +1141,20 @@
       next = PHI_ARG_DEF_FROM_EDGE (phi_old_loop, old_latch);
 
       /* Prefer using original variable as a base for the new ssa name.
-	 This is necessary for virtual ops, and useful in order to avoid
-	 losing debug info for real ops.  */
+     This is necessary for virtual ops, and useful in order to avoid
+     losing debug info for real ops.  */
       if (TREE_CODE (next) == SSA_NAME
-	  && useless_type_conversion_p (TREE_TYPE (next),
-					TREE_TYPE (init)))
-	new_init = copy_ssa_name (next, NULL);
+      && useless_type_conversion_p (TREE_TYPE (next),
+                    TREE_TYPE (init)))
+    new_init = copy_ssa_name (next, NULL);
       else if (TREE_CODE (init) == SSA_NAME
-	       && useless_type_conversion_p (TREE_TYPE (init),
-					     TREE_TYPE (next)))
-	new_init = copy_ssa_name (init, NULL);
+           && useless_type_conversion_p (TREE_TYPE (init),
+                         TREE_TYPE (next)))
+    new_init = copy_ssa_name (init, NULL);
       else if (useless_type_conversion_p (TREE_TYPE (next), TREE_TYPE (init)))
-	new_init = make_temp_ssa_name (TREE_TYPE (next), NULL, "unrinittmp");
+    new_init = make_temp_ssa_name (TREE_TYPE (next), NULL, "unrinittmp");
       else
-	new_init = make_temp_ssa_name (TREE_TYPE (init), NULL, "unrinittmp");
+    new_init = make_temp_ssa_name (TREE_TYPE (init), NULL, "unrinittmp");
 
       phi_rest = create_phi_node (new_init, rest);
 
@@ -1163,178 +1163,178 @@
       SET_USE (op, new_init);
     }
 
-  remove_path (exit);
+    remove_path (exit);
 
-  /* Transform the loop.  */
-  if (transform)
+    /* Transform the loop.  */
+    if (transform)
     (*transform) (loop, data);
 
-  /* Unroll the loop and remove the exits in all iterations except for the
+    /* Unroll the loop and remove the exits in all iterations except for the
      last one.  */
-  wont_exit = sbitmap_alloc (factor);
-  sbitmap_ones (wont_exit);
-  RESET_BIT (wont_exit, factor - 1);
+    wont_exit = sbitmap_alloc (factor);
+    sbitmap_ones (wont_exit);
+    RESET_BIT (wont_exit, factor - 1);
 
-  ok = gimple_duplicate_loop_to_header_edge
-	  (loop, loop_latch_edge (loop), factor - 1,
-	   wont_exit, new_exit, &to_remove, DLTHE_FLAG_UPDATE_FREQ);
-  free (wont_exit);
-  gcc_assert (ok);
+    ok = gimple_duplicate_loop_to_header_edge
+      (loop, loop_latch_edge (loop), factor - 1,
+       wont_exit, new_exit, &to_remove, DLTHE_FLAG_UPDATE_FREQ);
+    free (wont_exit);
+    gcc_assert (ok);
 
-  FOR_EACH_VEC_ELT (edge, to_remove, i, e)
+    FOR_EACH_VEC_ELT (edge, to_remove, i, e)
     {
       ok = remove_path (e);
       gcc_assert (ok);
     }
-  VEC_free (edge, heap, to_remove);
-  update_ssa (TODO_update_ssa);
+    VEC_free (edge, heap, to_remove);
+    update_ssa (TODO_update_ssa);
 
-  /* Ensure that the frequencies in the loop match the new estimated
+    /* Ensure that the frequencies in the loop match the new estimated
      number of iterations, and change the probability of the new
      exit edge.  */
-  freq_h = loop->header->frequency;
-  freq_e = EDGE_FREQUENCY (loop_preheader_edge (loop));
-  if (freq_h != 0)
+    freq_h = loop->header->frequency;
+    freq_e = EDGE_FREQUENCY (loop_preheader_edge (loop));
+    if (freq_h != 0)
     scale_loop_frequencies (loop, freq_e * (new_est_niter + 1), freq_h);
 
-  exit_bb = single_pred (loop->latch);
-  new_exit = find_edge (exit_bb, rest);
-  new_exit->count = loop_preheader_edge (loop)->count;
-  new_exit->probability = REG_BR_PROB_BASE / (new_est_niter + 1);
+    exit_bb = single_pred (loop->latch);
+    new_exit = find_edge (exit_bb, rest);
+    new_exit->count = loop_preheader_edge (loop)->count;
+    new_exit->probability = REG_BR_PROB_BASE / (new_est_niter + 1);
 
-  rest->count += new_exit->count;
-  rest->frequency += EDGE_FREQUENCY (new_exit);
+    rest->count += new_exit->count;
+    rest->frequency += EDGE_FREQUENCY (new_exit);
 
-  new_nonexit = single_pred_edge (loop->latch);
-  prob = new_nonexit->probability;
-  new_nonexit->probability = REG_BR_PROB_BASE - new_exit->probability;
-  new_nonexit->count = exit_bb->count - new_exit->count;
-  if (new_nonexit->count < 0)
+    new_nonexit = single_pred_edge (loop->latch);
+    prob = new_nonexit->probability;
+    new_nonexit->probability = REG_BR_PROB_BASE - new_exit->probability;
+    new_nonexit->count = exit_bb->count - new_exit->count;
+    if (new_nonexit->count < 0)
     new_nonexit->count = 0;
-  if (prob > 0)
+    if (prob > 0)
     scale_bbs_frequencies_int (&loop->latch, 1, new_nonexit->probability,
-			       prob);
+                   prob);
 
-  /* Finally create the new counter for number of iterations and add the new
+    /* Finally create the new counter for number of iterations and add the new
      exit instruction.  */
-  bsi = gsi_last_nondebug_bb (exit_bb);
-  exit_if = gsi_stmt (bsi);
-  create_iv (exit_base, exit_step, NULL_TREE, loop,
-	     &bsi, false, &ctr_before, &ctr_after);
-  gimple_cond_set_code (exit_if, exit_cmp);
-  gimple_cond_set_lhs (exit_if, ctr_after);
-  gimple_cond_set_rhs (exit_if, exit_bound);
-  update_stmt (exit_if);
+    bsi = gsi_last_nondebug_bb (exit_bb);
+    exit_if = gsi_stmt (bsi);
+    create_iv (exit_base, exit_step, NULL_TREE, loop,
+         &bsi, false, &ctr_before, &ctr_after);
+    gimple_cond_set_code (exit_if, exit_cmp);
+    gimple_cond_set_lhs (exit_if, ctr_after);
+    gimple_cond_set_rhs (exit_if, exit_bound);
+    update_stmt (exit_if);
 
 #ifdef ENABLE_CHECKING
-  verify_flow_info ();
-  verify_loop_structure ();
-  verify_loop_closed_ssa (true);
+    verify_flow_info ();
+    verify_loop_structure ();
+    verify_loop_closed_ssa (true);
 #endif
-}
+    }
 
-/* Wrapper over tree_transform_and_unroll_loop for case we do not
-   want to transform the loop before unrolling.  The meaning
-   of the arguments is the same as for tree_transform_and_unroll_loop.  */
+    /* Wrapper over tree_transform_and_unroll_loop for case we do not
+    want to transform the loop before unrolling.  The meaning
+    of the arguments is the same as for tree_transform_and_unroll_loop.  */
 
-void
-tree_unroll_loop (struct loop *loop, unsigned factor,
-		  edge exit, struct tree_niter_desc *desc)
-{
-  tree_transform_and_unroll_loop (loop, factor, exit, desc,
-				  NULL, NULL);
-}
+    void
+    tree_unroll_loop (struct loop *loop, unsigned factor,
+          edge exit, struct tree_niter_desc *desc)
+    {
+    tree_transform_and_unroll_loop (loop, factor, exit, desc,
+                  NULL, NULL);
+    }
 
-/* Rewrite the phi node at position PSI in function of the main
-   induction variable MAIN_IV and insert the generated code at GSI.  */
+    /* Rewrite the phi node at position PSI in function of the main
+    induction variable MAIN_IV and insert the generated code at GSI.  */
 
-static void
-rewrite_phi_with_iv (loop_p loop,
-		     gimple_stmt_iterator *psi,
-		     gimple_stmt_iterator *gsi,
-		     tree main_iv)
-{
-  affine_iv iv;
-  gimple stmt, phi = gsi_stmt (*psi);
-  tree atype, mtype, val, res = PHI_RESULT (phi);
+    static void
+    rewrite_phi_with_iv (loop_p loop,
+             gimple_stmt_iterator *psi,
+             gimple_stmt_iterator *gsi,
+             tree main_iv)
+    {
+    affine_iv iv;
+    gimple stmt, phi = gsi_stmt (*psi);
+    tree atype, mtype, val, res = PHI_RESULT (phi);
 
-  if (virtual_operand_p (res) || res == main_iv)
+    if (virtual_operand_p (res) || res == main_iv)
     {
       gsi_next (psi);
       return;
     }
 
-  if (!simple_iv (loop, loop, res, &iv, true))
+    if (!simple_iv (loop, loop, res, &iv, true))
     {
       gsi_next (psi);
       return;
     }
 
-  remove_phi_node (psi, false);
+    remove_phi_node (psi, false);
 
-  atype = TREE_TYPE (res);
-  mtype = POINTER_TYPE_P (atype) ? sizetype : atype;
-  val = fold_build2 (MULT_EXPR, mtype, unshare_expr (iv.step),
-		     fold_convert (mtype, main_iv));
-  val = fold_build2 (POINTER_TYPE_P (atype)
-		     ? POINTER_PLUS_EXPR : PLUS_EXPR,
-		     atype, unshare_expr (iv.base), val);
-  val = force_gimple_operand_gsi (gsi, val, false, NULL_TREE, true,
-				  GSI_SAME_STMT);
-  stmt = gimple_build_assign (res, val);
-  gsi_insert_before (gsi, stmt, GSI_SAME_STMT);
-  SSA_NAME_DEF_STMT (res) = stmt;
-}
+    atype = TREE_TYPE (res);
+    mtype = POINTER_TYPE_P (atype) ? sizetype : atype;
+    val = fold_build2 (MULT_EXPR, mtype, unshare_expr (iv.step),
+             fold_convert (mtype, main_iv));
+    val = fold_build2 (POINTER_TYPE_P (atype)
+             ? POINTER_PLUS_EXPR : PLUS_EXPR,
+             atype, unshare_expr (iv.base), val);
+    val = force_gimple_operand_gsi (gsi, val, false, NULL_TREE, true,
+                  GSI_SAME_STMT);
+    stmt = gimple_build_assign (res, val);
+    gsi_insert_before (gsi, stmt, GSI_SAME_STMT);
+    SSA_NAME_DEF_STMT (res) = stmt;
+    }
 
-/* Rewrite all the phi nodes of LOOP in function of the main induction
-   variable MAIN_IV.  */
+    /* Rewrite all the phi nodes of LOOP in function of the main induction
+    variable MAIN_IV.  */
 
-static void
-rewrite_all_phi_nodes_with_iv (loop_p loop, tree main_iv)
-{
-  unsigned i;
-  basic_block *bbs = get_loop_body_in_dom_order (loop);
-  gimple_stmt_iterator psi;
+    static void
+    rewrite_all_phi_nodes_with_iv (loop_p loop, tree main_iv)
+    {
+    unsigned i;
+    basic_block *bbs = get_loop_body_in_dom_order (loop);
+    gimple_stmt_iterator psi;
 
-  for (i = 0; i < loop->num_nodes; i++)
+    for (i = 0; i < loop->num_nodes; i++)
     {
       basic_block bb = bbs[i];
       gimple_stmt_iterator gsi = gsi_after_labels (bb);
 
       if (bb->loop_father != loop)
-	continue;
+    continue;
 
       for (psi = gsi_start_phis (bb); !gsi_end_p (psi); )
-	rewrite_phi_with_iv (loop, &psi, &gsi, main_iv);
+    rewrite_phi_with_iv (loop, &psi, &gsi, main_iv);
     }
 
-  free (bbs);
-}
+    free (bbs);
+    }
 
-/* Bases all the induction variables in LOOP on a single induction
-   variable (unsigned with base 0 and step 1), whose final value is
-   compared with *NIT.  When the IV type precision has to be larger
-   than *NIT type precision, *NIT is converted to the larger type, the
-   conversion code is inserted before the loop, and *NIT is updated to
-   the new definition.  When BUMP_IN_LATCH is true, the induction
-   variable is incremented in the loop latch, otherwise it is
-   incremented in the loop header.  Return the induction variable that
-   was created.  */
+    /* Bases all the induction variables in LOOP on a single induction
+    variable (unsigned with base 0 and step 1), whose final value is
+    compared with *NIT.  When the IV type precision has to be larger
+    than *NIT type precision, *NIT is converted to the larger type, the
+    conversion code is inserted before the loop, and *NIT is updated to
+    the new definition.  When BUMP_IN_LATCH is true, the induction
+    variable is incremented in the loop latch, otherwise it is
+    incremented in the loop header.  Return the induction variable that
+    was created.  */
 
-tree
-canonicalize_loop_ivs (struct loop *loop, tree *nit, bool bump_in_latch)
-{
-  unsigned precision = TYPE_PRECISION (TREE_TYPE (*nit));
-  unsigned original_precision = precision;
-  tree type, var_before;
-  gimple_stmt_iterator gsi, psi;
-  gimple stmt;
-  edge exit = single_dom_exit (loop);
-  gimple_seq stmts;
-  enum machine_mode mode;
-  bool unsigned_p = false;
+    tree
+    canonicalize_loop_ivs (struct loop *loop, tree *nit, bool bump_in_latch)
+    {
+    unsigned precision = TYPE_PRECISION (TREE_TYPE (*nit));
+    unsigned original_precision = precision;
+    tree type, var_before;
+    gimple_stmt_iterator gsi, psi;
+    gimple stmt;
+    edge exit = single_dom_exit (loop);
+    gimple_seq stmts;
+    enum machine_mode mode;
+    bool unsigned_p = false;
 
-  for (psi = gsi_start_phis (loop->header);
+    for (psi = gsi_start_phis (loop->header);
        !gsi_end_p (psi); gsi_next (&psi))
     {
       gimple phi = gsi_stmt (psi);
@@ -1343,45 +1343,45 @@
 
       type = TREE_TYPE (res);
       if (virtual_operand_p (res)
-	  || (!INTEGRAL_TYPE_P (type)
-	      && !POINTER_TYPE_P (type))
-	  || TYPE_PRECISION (type) < precision)
-	continue;
+      || (!INTEGRAL_TYPE_P (type)
+          && !POINTER_TYPE_P (type))
+      || TYPE_PRECISION (type) < precision)
+    continue;
 
       uns = POINTER_TYPE_P (type) | TYPE_UNSIGNED (type);
 
       if (TYPE_PRECISION (type) > precision)
-	unsigned_p = uns;
+    unsigned_p = uns;
       else
-	unsigned_p |= uns;
+    unsigned_p |= uns;
 
       precision = TYPE_PRECISION (type);
     }
 
-  mode = smallest_mode_for_size (precision, MODE_INT);
-  precision = GET_MODE_PRECISION (mode);
-  type = build_nonstandard_integer_type (precision, unsigned_p);
+    mode = smallest_mode_for_size (precision, MODE_INT);
+    precision = GET_MODE_PRECISION (mode);
+    type = build_nonstandard_integer_type (precision, unsigned_p);
 
-  if (original_precision != precision)
+    if (original_precision != precision)
     {
       *nit = fold_convert (type, *nit);
       *nit = force_gimple_operand (*nit, &stmts, true, NULL_TREE);
       if (stmts)
-	gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);
+    gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);
     }
 
-  if (bump_in_latch)
+    if (bump_in_latch)
     gsi = gsi_last_bb (loop->latch);
-  else
+    else
     gsi = gsi_last_nondebug_bb (loop->header);
-  create_iv (build_int_cst_type (type, 0), build_int_cst (type, 1), NULL_TREE,
-	     loop, &gsi, bump_in_latch, &var_before, NULL);
+    create_iv (build_int_cst_type (type, 0), build_int_cst (type, 1), NULL_TREE,
+         loop, &gsi, bump_in_latch, &var_before, NULL);
 
-  rewrite_all_phi_nodes_with_iv (loop, var_before);
+    rewrite_all_phi_nodes_with_iv (loop, var_before);
 
-  stmt = last_stmt (exit->src);
-  /* Make the loop exit if the control condition is not satisfied.  */
-  if (exit->flags & EDGE_TRUE_VALUE)
+    stmt = last_stmt (exit->src);
+    /* Make the loop exit if the control condition is not satisfied.  */
+    if (exit->flags & EDGE_TRUE_VALUE)
     {
       edge te, fe;
 
@@ -1389,10 +1389,10 @@
       te->flags = EDGE_FALSE_VALUE;
       fe->flags = EDGE_TRUE_VALUE;
     }
-  gimple_cond_set_code (stmt, LT_EXPR);
-  gimple_cond_set_lhs (stmt, var_before);
-  gimple_cond_set_rhs (stmt, *nit);
-  update_stmt (stmt);
+    gimple_cond_set_code (stmt, LT_EXPR);
+    gimple_cond_set_lhs (stmt, var_before);
+    gimple_cond_set_rhs (stmt, *nit);
+    update_stmt (stmt);
 
-  return var_before;
-}
+    return var_before;
+    }
Index: gcc/tree-pass.h
===================================================================
--- gcc/tree-pass.h	(revision 192574)
+++ gcc/tree-pass.h	(working copy)
@@ -281,6 +281,7 @@
 extern struct gimple_opt_pass pass_graphite;
 extern struct gimple_opt_pass pass_graphite_transforms;
 extern struct gimple_opt_pass pass_if_conversion;
+extern struct gimple_opt_pass pass_loop_fusion; 
 extern struct gimple_opt_pass pass_loop_distribution;
 extern struct gimple_opt_pass pass_vectorize;
 extern struct gimple_opt_pass pass_slp_vectorize;
Index: gcc/testsuite/gfortran.dg/vect/vect.exp
===================================================================
--- gcc/testsuite/gfortran.dg/vect/vect.exp	(revision 192574)
+++ gcc/testsuite/gfortran.dg/vect/vect.exp	(working copy)
@@ -28,6 +28,9 @@
 lappend DEFAULT_VECTCFLAGS "-O2" "-ftree-vectorize" "-fno-vect-cost-model" \
   "-fdump-tree-vect-details"
 
+# Disable Loop Fusion
+lappend DEFAULT_VECTCFLAGS "-fno-tree-loop-fusion" 
+
 # If the target system supports vector instructions, the default action
 # for a test is 'run', otherwise it's 'compile'.  Save current default.
 # Executing vector instructions on a system without hardware vector support
Index: gcc/testsuite/gcc.dg/autopar/autopar.exp
===================================================================
--- gcc/testsuite/gcc.dg/autopar/autopar.exp	(revision 192574)
+++ gcc/testsuite/gcc.dg/autopar/autopar.exp	(working copy)
@@ -29,6 +29,9 @@
     set DEFAULT_CFLAGS " -ansi -pedantic-errors"
 }
 
+# Loop Fusion has to be disabled for the tests
+lappend DEFAULT_CFLAGS "-fno-tree-loop-fusion"
+
 # Initialize `dg'.
 dg-init
 
Index: gcc/testsuite/gcc.dg/tree-ssa/lfusion-1.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/lfusion-1.c	(revision 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/lfusion-1.c	(revision 0)
@@ -0,0 +1,22 @@
+/* { dg-do compile } */ 
+/* { dg-options "-O2 -ftree-loop-fusion -fdump-tree-lfusion-all" } */
+
+void loop(int * __restrict__ ia){
+    unsigned int array[100];
+    unsigned int sum = 0;
+    
+    unsigned int i;
+    for(i = 0; i < 100; ++i){
+        array[i] = i;
+    }
+    
+    unsigned int j;
+    for(j = 0; j < 100; ++j){
+        sum += array[j];
+    }
+
+    *ia = sum;
+}
+
+/* { dg-final { scan-tree-dump-times "Loop Fused: 1" 1 "lfusion" } } */
+/* { dg-final { cleanup-tree-dump "lfusion" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/lfusion-2.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/lfusion-2.c	(revision 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/lfusion-2.c	(revision 0)
@@ -0,0 +1,29 @@
+/* { dg-do compile } */ 
+/* { dg-options "-O2 -ftree-loop-fusion -fdump-tree-lfusion-all" } */
+
+void loop(int * __restrict__ ia, int * __restrict__ ib){
+    unsigned int array1[100];
+    unsigned int array2[100];
+    unsigned int sum = 0;
+    
+    unsigned int i;
+    for(i = 0; i < 100; ++i){
+        array1[i] = i;
+    }
+    
+    unsigned int k;
+    for(k = 0; k < 100; ++k){
+        array2[k] = array1[k];
+    }
+
+    unsigned int j;
+    for(j = 0; j < 100; ++j){
+        sum += array1[j];
+    }
+
+    *ia = sum;
+    *ib = array2[99];
+}
+
+/* { dg-final { scan-tree-dump-times "Loop Fused: 2" 1 "lfusion" } } */
+/* { dg-final { cleanup-tree-dump "lfusion" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/lfusion-3.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/lfusion-3.c	(revision 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/lfusion-3.c	(revision 0)
@@ -0,0 +1,30 @@
+/* { dg-do compile } */ 
+/* { dg-options "-O2 -ftree-loop-fusion -fdump-tree-lfusion-all" } */
+
+void loop(int * __restrict__ ia){
+    unsigned int array[100];
+    unsigned int sum = 0;
+        
+    unsigned int i;
+    for(i = 0; i < 100; ++i){
+        array[i] = i;
+    }
+    
+    unsigned int j;
+    for(j = 0; j < 10; ++j){
+        unsigned int k;
+        for(k = 0; k < 100; ++k){
+            sum += array[k];
+        }
+
+        unsigned l;
+        for(l = 0; l < 100; ++l){
+            sum += array[l];
+        }
+    }
+
+    *ia = sum;
+}
+
+/* { dg-final { scan-tree-dump-times "Loop Fused: " 0 "lfusion" } } */
+/* { dg-final { cleanup-tree-dump "lfusion" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/lfusion-4.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/lfusion-4.c	(revision 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/lfusion-4.c	(revision 0)
@@ -0,0 +1,34 @@
+/* { dg-do compile } */ 
+/* { dg-options "-O2 -ftree-loop-fusion -fdump-tree-lfusion-all" } */
+
+void loop(int * __restrict__ ia){
+    unsigned int array1[100];
+    unsigned int array2[100];
+    unsigned int array3[100];
+    unsigned int array4[100];
+    
+    unsigned int i;
+    for(i = 0; i < 100; ++i){
+        array1[i] = i;
+    }
+    
+    unsigned int j;
+    for(j = 0; j < 100; ++j){
+        array2[j] = array1[j];
+    }
+    
+    unsigned int k;
+    for(k = 0; k < 100; ++k){
+        array3[k] = array2[k];
+    }
+    
+    unsigned int l;
+    for(l = 0; l < 100; ++l){
+        array4[l] = array3[l];
+    }
+
+    *ia = array4[99];
+}
+
+/* { dg-final { scan-tree-dump-times "Loop Fused: 3" 1 "lfusion" } } */
+/* { dg-final { cleanup-tree-dump "lfusion" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/lfusion-5.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/lfusion-5.c	(revision 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/lfusion-5.c	(revision 0)
@@ -0,0 +1,23 @@
+/* { dg-do compile } */ 
+/* { dg-options "-O2 -ftree-loop-fusion -fdump-tree-lfusion-all" } */
+
+void loop(int * __restrict__ ia, int * __restrict__ ib){
+    unsigned int A[100];
+    unsigned int B[100];
+    
+    unsigned int i;
+    for(i = 0; i < 100; ++i){
+        A[i] = 2;
+    }
+
+    unsigned int j;
+    for(j = 0; j < 100; ++j){
+        B[j] = 1 + A[j + 1];
+    }
+
+    *ia = A[99];
+    *ib = B[99];
+}
+
+/* { dg-final { scan-tree-dump-times "Loop Fused: " 0 "lfusion" } } */
+/* { dg-final { cleanup-tree-dump "lfusion" } } */
Index: gcc/testsuite/gcc.dg/vect/vect.exp
===================================================================
--- gcc/testsuite/gcc.dg/vect/vect.exp	(revision 192574)
+++ gcc/testsuite/gcc.dg/vect/vect.exp	(working copy)
@@ -42,6 +42,9 @@
 # These flags are used for all targets.
 lappend DEFAULT_VECTCFLAGS "-ftree-vectorize" "-fno-vect-cost-model" "-fno-common"
 
+# Loop Fusion has to be disabled for the tests
+lappend DEFAULT_VECTCFLAGS "-fno-tree-loop-fusion"
+
 # Initialize `dg'.
 dg-init
 
Index: gcc/tree-loop-fusion.c
===================================================================
--- gcc/tree-loop-fusion.c	(revision 0)
+++ gcc/tree-loop-fusion.c	(revision 0)
@@ -0,0 +1,1047 @@
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tree.h"
+
+#include "basic-block.h"
+#include "tree-flow.h"
+#include "tree-dump.h"
+#include "timevar.h"
+#include "cfgloop.h"
+#include "tree-chrec.h"
+#include "tree-data-ref.h"
+#include "tree-scalar-evolution.h"
+#include "tree-pass.h"
+#include "tree-ssa-alias.h"
+
+#include <iostream>
+
+/* 
+   This pass performs loop fusion: for example, the loops
+
+   |DO I = 1, N
+   |    A(I) = I
+   |ENDDO
+   
+   |DO I = 1, N
+   |    B(I) = A(I)
+   |ENDDO
+
+   will be transformed to
+
+   |DO I = 1, N
+   |    A(I) = I
+   |    B(I) = A(I)
+   |ENDDO
+
+*/
+
+static struct
+{
+  /* The number of loops fused. */
+  int fused;
+
+  /* The number of basic blocks merged during the cleanup pass */
+  int merged;
+
+} fusion_stats;
+
+/* Print a debug message if logging is enabled */
+
+static void
+print (const char* message)
+{
+    if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+        fprintf (dump_file, message);
+    }
+}
+
+/* 
+ * Print the current function to to the dump file 
+ * if logging is enabled. 
+ */
+
+static void 
+full_debug (const char* state)
+{
+    if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+        fprintf (dump_file, state);
+        dump_function_to_file (current_function_decl, dump_file, dump_flags);
+    }
+}
+
+/* Return the last BB (last in the instruction stream) */
+
+static basic_block 
+get_last_bb (struct loop *loop)
+{
+    basic_block header = loop->header;
+    basic_block latch = loop->latch;
+
+    if (header->next_bb == latch)
+    {
+       return latch; 
+    } 
+    else 
+    {
+        return header;
+    }
+}
+
+/* Return the first BB (first in the instruction stream) */
+
+static basic_block 
+get_first_bb (struct loop *loop)
+{
+    basic_block header = loop->header;
+    basic_block latch = loop->latch;
+
+    if (header->next_bb == latch)
+    {
+       return header; 
+    } 
+    else 
+    {
+        return latch;
+    }
+}
+
+/* Return the number of basic blocks between the two loops */
+
+static unsigned int
+distance_between_loops (struct loop *loop_first, struct loop *loop_next)
+{
+    //Some loops appears to have their latch first, so taking latch and header
+    //is not enough to determine the distance
+    basic_block current = get_last_bb (loop_first);
+    basic_block header_next = get_first_bb (loop_next);
+
+    unsigned int distance = 0;
+
+    while (current->next_bb != header_next)
+    {
+        ++distance;
+        current = current->next_bb;
+    }
+
+    return distance;
+}
+
+/* 
+ * Return the basic block between the two loops. 
+ * Assumes that the distance between the loops is 1. 
+ */
+
+static basic_block
+basic_block_between (struct loop *loop_first, struct loop* loop_next)
+{
+    //Some loops appears to have their latch first, so taking latch and header
+    //is not enough to determine the distance
+    basic_block last_bb = get_last_bb (loop_first);
+
+    basic_block between_bb = last_bb->next_bb;
+
+    gcc_assert (between_bb->next_bb == get_first_bb (loop_next));
+
+    return between_bb;
+}
+
+/* Return the induction variable SSA name for this loop */
+
+static tree 
+get_ssa_name_iv (struct loop* loop)
+{
+    tree ssa_iv_name = NULL_TREE;
+
+    for (gimple_stmt_iterator gsi = gsi_start_bb (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))
+    {
+        gimple stmt = gsi_stmt (gsi);
+
+        if (gimple_code (stmt) == GIMPLE_COND)
+        {
+            tree lhs = gimple_cond_lhs (stmt);
+            tree rhs = gimple_cond_rhs (stmt);
+
+            if (TREE_CODE (lhs) == SSA_NAME)
+            {
+                ssa_iv_name = lhs;
+            }
+            else if (TREE_CODE (rhs) == SSA_NAME)
+            {
+                ssa_iv_name = rhs;
+            } 
+        }
+    }
+
+    gcc_assert (ssa_iv_name != NULL_TREE);
+
+    return ssa_iv_name;
+}
+
+/* Return the PHI LHS for the given SSA name in the given loop */
+
+static tree 
+get_phi_var_for_iv(struct loop *loop, tree ssa_iv_name)
+{
+    tree def = NULL_TREE;
+    
+    for (gimple_stmt_iterator gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))
+    {
+        gimple phi = gsi_stmt (gsi);
+        
+        if (SSA_NAME_VAR (gimple_phi_result (phi)) == SSA_NAME_VAR (ssa_iv_name))
+        {
+            def = gimple_phi_result (phi);
+            break;
+        }
+    }
+
+    return def;
+}
+
+/* 
+ * This function fuses two loops together 
+ *
+ * The two functions have to be mergeable and mergeable together 
+ * before this function is called. 
+ */
+
+static void
+fuse_loops (struct loop* loop_first, struct loop* loop_next)
+{
+    if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+        fprintf (dump_file, "Fusion of A=%d and B=%d\n", loop_first->num, loop_next->num);
+        full_debug ("Before fusion\n");
+    }
+
+    /* 1. Replace the induction variable */
+
+    tree ssa_iv_name_first = get_ssa_name_iv (loop_first);
+    tree ssa_iv_name_next = get_ssa_name_iv (loop_next);
+    
+    tree use = get_phi_var_for_iv (loop_first, ssa_iv_name_first);
+    tree def = get_phi_var_for_iv (loop_next, ssa_iv_name_next);
+    
+    //Normally guaranteed by the conditions before fusing
+    gcc_assert (use != NULL_TREE);
+    gcc_assert (def != NULL_TREE);
+    
+    replace_uses_by (def, use);
+    
+    full_debug ("After IV replacing\n");
+
+    /* 2. Transfer other PHI nodes */
+
+    edge old_entry_edge = loop_preheader_edge (loop_next);
+    edge old_latch_edge = loop_latch_edge (loop_next);
+    
+    edge new_entry_edge = loop_preheader_edge (loop_first);
+    edge new_latch_edge = loop_latch_edge (loop_first);
+    
+    for (gimple_stmt_iterator gsi = gsi_start_phis (loop_next->header); 
+            !gsi_end_p (gsi); )
+    {
+        gimple phi_orig = gsi_stmt (gsi);
+        tree result = gimple_phi_result ( phi_orig);
+        
+        if (SSA_NAME_VAR (result) != SSA_NAME_VAR (ssa_iv_name_next))
+        {
+            print ("Found a PHI node to copy \n");
+
+            gimple phi_new = create_phi_node (result, loop_first->header);
+        
+            tree def;
+            source_location locus;
+
+            /* Copy the first PHI arg (coming from entry) */
+            def = PHI_ARG_DEF_FROM_EDGE (phi_orig, old_entry_edge);
+            locus = gimple_phi_arg_location_from_edge (phi_orig, old_entry_edge);
+            add_phi_arg (phi_new, def, new_entry_edge, locus);
+            
+            /* Copy the second PHI arg (coming from the latch) */
+            def = PHI_ARG_DEF_FROM_EDGE (phi_orig, old_latch_edge);
+            locus = gimple_phi_arg_location_from_edge (phi_orig, old_latch_edge);
+            add_phi_arg (phi_new, def, new_latch_edge, locus);
+
+            //We do not want the SSA name to be released
+            remove_phi_node (&gsi, false);
+        } 
+        else 
+        {
+            //The SSA name can be released
+            remove_phi_node (&gsi, true);
+        }
+    }
+    
+    full_debug ("After transfer of PHI nodes\n");
+
+    /* 3. Transfer all the statements */
+    
+    gimple_stmt_iterator gsi_first_last = gsi_last_bb (loop_first->header);
+    gsi_prev (&gsi_first_last);
+
+    for (gimple_stmt_iterator gsi = gsi_start_bb (loop_next->header); 
+            !gsi_end_p (gsi);)
+    {
+        gimple stmt = gsi_stmt (gsi);
+
+        if (gimple_code(stmt) != GIMPLE_COND)
+        {
+            update_stmt (stmt);
+            gsi_move_before (&gsi, &gsi_first_last);
+            update_stmt (stmt);
+        }
+        else
+        {
+            gsi_next (&gsi);
+        }
+    }
+    
+    full_debug ("After transfer of statements\n");
+
+    /* 5. Delete the loop A */
+    
+    //Save them before loop gets deleted
+    basic_block between_bb = basic_block_between (loop_first, loop_next);
+    basic_block header_next = loop_next->header;
+    basic_block latch_next = loop_next->latch;
+    basic_block next_bb = get_last_bb (loop_next)->next_bb;
+    
+    //Move header_next and latch_next in the outer loop
+    remove_bb_from_loops (header_next);
+    add_bb_to_loop (header_next, loop_outer (loop_first));
+    
+    remove_bb_from_loops (latch_next);
+    add_bb_to_loop (latch_next, loop_outer (loop_first));
+    
+    delete_loop(loop_next);
+        
+    delete_basic_block(latch_next);
+        
+    full_debug ("After removing the loop\n");
+
+    /* 6. Fix edges */
+
+    //Fix the type of the edge
+    single_succ_edge (header_next)->flags |= EDGE_FALLTHRU;
+    single_succ_edge (header_next)->flags &= ~EDGE_TRUE_VALUE;
+    single_succ_edge (header_next)->flags &= ~EDGE_FALSE_VALUE;
+    
+    //Remove the condition from the old loop header
+    for (gimple_stmt_iterator gsi = gsi_start_bb (header_next); !gsi_end_p (gsi);)
+    {
+        gimple stmt = gsi_stmt (gsi);
+
+        if (gimple_code (stmt) == GIMPLE_COND)
+        {
+            gsi_remove (&gsi, true);
+        }
+        else
+        {
+            gsi_next (&gsi);
+        }
+    }
+    
+    full_debug ("After fixing the edges \n");
+
+    /* 7. Clean the basic blocks */
+
+    //Remove the between block if possible
+    if (gimple_seq_empty_p (phi_nodes (between_bb)) 
+            && gimple_seq_empty_p (bb_seq (between_bb)))
+    {
+        redirect_edge_and_branch (single_pred_edge (between_bb), header_next);
+
+        delete_basic_block (between_bb);
+    } 
+    else 
+    {
+        set_immediate_dominator (CDI_DOMINATORS, between_bb, 
+                recompute_dominator (CDI_DOMINATORS, between_bb));
+    }
+    
+    full_debug ("After cleaning basic blocks\n");
+
+    /* 7. Update SSA */
+
+    update_ssa (TODO_update_ssa);
+
+    /* 8. Update dominators */
+    
+    set_immediate_dominator (CDI_DOMINATORS, loop_first->header, 
+            recompute_dominator (CDI_DOMINATORS, loop_first->header));
+    set_immediate_dominator (CDI_DOMINATORS, loop_first->latch, 
+            recompute_dominator (CDI_DOMINATORS, loop_first->latch));
+    set_immediate_dominator (CDI_DOMINATORS, next_bb, 
+            recompute_dominator (CDI_DOMINATORS, next_bb));
+    set_immediate_dominator (CDI_DOMINATORS, header_next, 
+            recompute_dominator (CDI_DOMINATORS, header_next));
+
+    /* 9. Fix the profile information */
+
+    //TODO Restore the profile information
+    
+    full_debug ("After fusion\n");
+
+    ++fusion_stats.fused;
+}
+
+/* Indicates if the specified basic block can be merged */
+
+static bool
+dirty (basic_block bb)
+{
+    if (gimple_seq_empty_p (bb_seq (bb)) && gimple_seq_empty_p (phi_nodes (bb)))
+    {
+        return single_succ_p (bb) && single_pred_p (bb);
+    }
+
+    return false;
+}
+
+/* Tries to find basic blocks to be merged */
+
+static void
+cleanup ()
+{
+    basic_block bb;
+    
+    FOR_EACH_BB(bb)
+    {
+        if (dirty(bb))
+        {
+            basic_block bb_next = bb->next_bb;
+
+            if (bb_next && dirty (bb_next))
+            {
+                //They have to fall through the instruction stream
+                if (single_succ_edge (bb)->dest == bb_next)
+                {
+                    merge_blocks (bb, bb_next);
+                    
+                    ++fusion_stats.merged;
+                }
+            }
+        }
+    }
+}
+
+/* 
+ * Returns true if the access functions are equivalent, 
+ * the induction variable may vary. 
+ */
+
+static bool
+are_equivalent_functions (const_tree chrec0, const_tree chrec1)
+{
+    if (chrec0 == NULL_TREE || chrec1 == NULL_TREE 
+            || TREE_CODE (chrec0) != TREE_CODE (chrec1))
+    {
+        return false;
+    }
+
+    if (chrec0 == chrec1)
+    {
+        return true;
+    }
+
+    switch (TREE_CODE (chrec0))
+    {
+        case INTEGER_CST:
+            return operand_equal_p (chrec0, chrec1, 0);
+
+        case POLYNOMIAL_CHREC:
+            return eq_evolutions_p (CHREC_LEFT (chrec0), CHREC_LEFT (chrec1))
+                && eq_evolutions_p (CHREC_RIGHT (chrec0), CHREC_RIGHT (chrec1));
+
+        case PLUS_EXPR:
+        case MULT_EXPR:
+        case MINUS_EXPR:
+        case POINTER_PLUS_EXPR:
+            return eq_evolutions_p (TREE_OPERAND (chrec0, 0), TREE_OPERAND (chrec1, 0))
+                && eq_evolutions_p (TREE_OPERAND (chrec0, 1), TREE_OPERAND (chrec1, 1));
+
+        default:
+            return false;
+    }
+}
+
+/* 
+ * Returns true if both data references have equivalent access function, 
+ * the induction variable may change. 
+ */
+
+static bool
+are_equivalent (data_reference_p a, data_reference_p b)
+{
+    unsigned int i;
+
+    /* The references are exactly the same.  */
+    if (operand_equal_p (DR_REF (a), DR_REF (b), 0))
+    {
+        return true;
+    }
+
+    if (!same_data_refs_base_objects (a, b))
+    {
+        return false;
+    }
+
+    for (i = 0; i < DR_NUM_DIMENSIONS (a); i++)
+    {
+        if (!are_equivalent_functions (DR_ACCESS_FN (a, i), DR_ACCESS_FN (b, i)))
+        {
+            return false;
+        }
+    }
+
+    //TODO Verify the var of each data reference is the induction variable
+
+    return true;
+}
+
+static inline bool
+deep_same_data_refs_base_objects (data_reference_p a, data_reference_p b)
+{
+    /*print ("Compare two data references\n");
+
+    if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+        dump_data_reference(dump_file, a);
+        dump_data_reference(dump_file, b);
+    }*/
+
+    /*if(dr_may_alias_p (a, b, true)){
+        print("They may alias \n");
+    }
+
+    if(TREE_CODE( DR_BASE_OBJECT (a)) == MEM_REF && TREE_CODE( DR_BASE_OBJECT (b)) == MEM_REF){
+        tree left_a = TREE_OPERAND (DR_BASE_OBJECT (a), 0);
+        tree left_b = TREE_OPERAND (DR_BASE_OBJECT (b), 0);
+
+        if(refs_may_alias_p (left_a, left_b)){
+            print("The refs may alias \n");
+        }
+    }*/
+
+    bool same = same_data_refs_base_objects(a, b);
+
+    /*if(same)
+    {
+        print("A and B are to the same object\n");
+    }
+    else
+    {
+        print("A and B are not to the same object\n");
+    }*/
+
+    return same;
+}
+
+/* Returns true if loops are independent. */
+
+static bool
+are_independent (struct loop *loop_first, struct loop *loop_next)
+{
+    VEC (data_reference_p, heap) *datarefs_next = 
+        VEC_alloc (data_reference_p, heap, 10);
+    VEC (data_reference_p, heap) *datarefs_first = 
+        VEC_alloc (data_reference_p, heap, 10);
+
+    VEC (ddr_p, heap) *dependence_relations_next = 
+        VEC_alloc (ddr_p, heap, 10 * 10);
+    VEC (ddr_p, heap) *dependence_relations_first = 
+        VEC_alloc (ddr_p, heap, 10 * 10);
+
+    VEC (loop_p, heap) *loop_nest_next = VEC_alloc (loop_p, heap, 3);
+    VEC (loop_p, heap) *loop_nest_first = VEC_alloc (loop_p, heap, 3);
+
+    bool success = true;
+    success &= compute_data_dependences_for_loop (loop_first, true, &loop_nest_first, 
+            &datarefs_first, &dependence_relations_first);
+    success &= compute_data_dependences_for_loop (loop_next, true, &loop_nest_next, 
+            &datarefs_next, &dependence_relations_next); 
+
+    //If the data dependence does not success, we consider the loops as dependent
+    bool ret = false;
+
+    if (!success)
+    {
+        print ("Data dependence analysis failed\n");
+    }
+    else
+    {
+        //If no dependences are found later, the loops are not dependent
+        ret = true;
+
+        data_reference_p ref_first;
+        data_reference_p ref_next;
+        unsigned int i;
+        unsigned int j;
+
+        //Dump data references
+        if (dump_file && (dump_flags & TDF_DETAILS))
+        {
+            fprintf (dump_file, "Print data reference of A\n");
+            FOR_EACH_VEC_ELT (data_reference_p, datarefs_first, i, ref_first)
+            {
+                if (!ref_first || !DR_STMT (ref_first))
+                {
+                    fprintf (dump_file, "Null data reference\n");
+                } 
+                else 
+                {
+                    dump_data_reference (dump_file, ref_first);
+                }
+            }
+
+            fprintf (dump_file, "Print data reference of B\n");
+            FOR_EACH_VEC_ELT (data_reference_p, datarefs_next, j, ref_next)
+            {
+                if (!ref_next || !DR_STMT (ref_next))
+                {
+                    fprintf (dump_file, "Null data reference\n");
+                } 
+                else 
+                {
+                    dump_data_reference (dump_file, ref_next);
+                }
+            }
+
+            fprintf (dump_file, "Print data dependence relations of A\n");
+            dump_data_dependence_relations (dump_file, dependence_relations_first);
+            
+            fprintf (dump_file, "Print data dependence relations of B\n");
+            dump_data_dependence_relations (dump_file, dependence_relations_next);
+        }
+        
+        ddr_p ddr;
+
+        FOR_EACH_VEC_ELT (ddr_p, dependence_relations_first, i, ddr)
+        {
+            if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)
+            {
+                print ("A and B are not independent due don't know relation in A\n");
+                ret = false;
+                break;
+            }
+        }
+        
+        FOR_EACH_VEC_ELT (ddr_p, dependence_relations_next, i, ddr)
+        {
+            if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)
+            {
+                print ("A and B are not independent due don't know relation in B\n");
+                ret = false;
+                break;
+            }
+        }
+
+        //Only if there are no "don't know" data dependence relations
+        if (ret)
+        {
+            //Consider each pair of dependences between the loops
+            FOR_EACH_VEC_ELT (data_reference_p, datarefs_first, i, ref_first)
+            {
+                //TODO Find what to do with these "NULL" references
+                if (!ref_first || !DR_STMT (ref_first))
+                {
+                    print ("A and B are not independent due to unresolved dependences\n");
+                    ret = false;
+                    break;
+                }
+
+                FOR_EACH_VEC_ELT (data_reference_p, datarefs_next, j, ref_next)
+                {
+                    //TODO Find what to do with these "NULL" references
+                    if (!ref_next || !DR_STMT (ref_next))
+                    {
+                        print ("A and B are not independent due to unresolved dependences\n");
+                        ret = false;
+                        break;
+                    }
+
+                    if (deep_same_data_refs_base_objects (ref_first, ref_next))
+                    {
+                        if (DR_IS_READ (ref_first) && DR_IS_READ (ref_next))
+                        {
+                            print ("Found an input-dependence\n");
+                            //Input reference can be ignored
+                        } 
+                        else if (DR_IS_WRITE (ref_first) && DR_IS_WRITE (ref_next))
+                        {
+                            print ("Found an output-dependence\n");
+
+                            if (!are_equivalent (ref_first, ref_next))
+                            {
+                                print ("An output-dependence is blocking\n");
+                                ret = false;
+                            }
+                        } 
+                        else if (DR_IS_READ (ref_first) && DR_IS_WRITE (ref_next))
+                        {
+                            print ("Found an anti-dependence\n");
+
+                            if (!are_equivalent (ref_first, ref_next))
+                            {
+                                print ("An anti-dependence is blocking\n");
+                                ret = false;
+                            }
+                        } 
+                        else if (DR_IS_WRITE (ref_first) && DR_IS_READ (ref_next))
+                        {
+                            print ("Found a true-dependence\n");
+
+                            if (!are_equivalent (ref_first, ref_next))
+                            {
+                                print ("A true-dependence is blocking\n");
+                                ret = false;
+                            }
+                        }
+                    }
+                }
+
+                if (!ret)
+                {
+                    break;
+                }
+            }
+        }
+    }
+
+    free_dependence_relations (dependence_relations_next);
+    free_dependence_relations (dependence_relations_first);
+
+    free_data_refs (datarefs_next);
+    free_data_refs (datarefs_first);
+
+    VEC_free (loop_p, heap, loop_nest_next);
+    VEC_free (loop_p, heap, loop_nest_first);
+
+    return ret;
+}
+
+/* Return the index of the basic block in the instruction stream */
+
+static unsigned int
+bb_stream_index (basic_block block)
+{
+    unsigned int index = 0;
+
+    basic_block bb;
+    FOR_EACH_BB (bb)
+    {
+        if (bb == block)
+        {
+            break;
+        }
+
+        ++index;
+    }
+
+    return index;
+}
+
+/* Verify if this loop is supported by the merging algorithm */
+
+static bool 
+loop_is_mergeable (struct loop* loop)
+{
+    //The algorithm will fail on loop with more than one exit
+    if (!single_exit (loop))
+    {
+        return false; 
+    }
+
+    //It is necessary to know the number of times a loop will iterate
+    if (!loop->any_estimate || !loop->any_upper_bound)
+    {
+        return false;
+    }
+    
+    //It is necessary to have a precise estimate
+    if (loop->nb_iterations_estimate != loop->nb_iterations_upper_bound)
+    {
+        return false;
+    }
+     
+    //The algorithm only supports loops with a header and a latch
+    if (loop->num_nodes > 2)
+    {
+        return false;
+    }
+
+    //The latch must be empty because the statements are not transferred to the other latch
+    if (!gimple_seq_empty_p (bb_seq (loop->latch)) || !gimple_seq_empty_p (phi_nodes (loop->latch)))
+    {
+        return false;
+    }
+    
+    tree ssa_iv_name = get_ssa_name_iv (loop);
+
+    //The Induction Variable is not of integer type
+    if (TREE_CODE (TREE_TYPE (ssa_iv_name)) != INTEGER_TYPE)
+    {
+        return false;
+    }
+
+    //With a NULL_TREE, we are not able to find the correct PHI node
+    if (SSA_NAME_VAR (ssa_iv_name) == NULL_TREE)
+    {
+        return false;
+    }
+
+    tree phi_iv = get_phi_var_for_iv (loop, ssa_iv_name);
+
+    //The PHI node is necessary for renaming
+    if (phi_iv == NULL_TREE)
+    {
+        return false;
+    }
+    
+    basic_block header = loop->header;
+    basic_block latch = loop->latch;
+
+    //The header and the latch should be sibling in the instruction stream
+    if (!(header->next_bb == latch || latch->next_bb == header))
+    {
+        return false;
+    }
+
+    return true;
+}
+
+/* Return true if the loops can be fused. Both loops have to be mergeable. */
+
+static bool
+loops_are_mergeable (struct loop *loop_first, struct loop *loop_next)
+{
+    //Both loop should iterate the same number of times
+    if (loop_next->nb_iterations_estimate != loop_first->nb_iterations_estimate)
+    {
+        return false;
+    }
+
+    //Only support loops with only one basic block between them
+    unsigned int distance = distance_between_loops (loop_first, loop_next);
+    if (distance != 1)
+    {
+        print ("The distance is too high\n");
+
+        return false;
+    }
+
+    basic_block between_bb = basic_block_between (loop_first, loop_next);
+
+    //The two loops must be always executed together
+    if (!single_succ_p (between_bb) || !single_pred_p (between_bb))
+    {
+        print ("The between block has too many predecessors or successors\n");
+
+        return false;
+    }
+
+    //Only empty block between A and B are supported
+    if (!gimple_seq_empty_p( bb_seq( between_bb)))
+    {
+        print ("Too many statements in the between block\n");
+
+        return false;
+    }
+
+    //Only empty block between A and B are supported
+    if (!gimple_seq_empty_p( phi_nodes( between_bb)))
+    {
+        print ("Too many PHI nodes in the between block\n");
+
+        return false;
+    }
+    
+    tree ssa_iv_name_first = get_ssa_name_iv (loop_first);
+    tree ssa_iv_name_next = get_ssa_name_iv (loop_next);
+
+    tree type_iv_first = TREE_TYPE(ssa_iv_name_first);
+    tree type_iv_next = TREE_TYPE(ssa_iv_name_next);
+
+    //The induction variables must be both signed or both unsigned
+    if ((TYPE_UNSIGNED (type_iv_first) && !TYPE_UNSIGNED (type_iv_next)) 
+            || (!TYPE_UNSIGNED (type_iv_first) && TYPE_UNSIGNED (type_iv_next))){
+        return false;
+    }
+    
+    //The induction variables must of same precision
+    if (TYPE_PRECISION (type_iv_first) != TYPE_PRECISION (type_iv_next)){
+        return false;
+    }
+
+    //If all the other conditions are, 
+    //the loops needs only to be independent to be fused
+    return are_independent (loop_first, loop_next);
+}
+
+/* 
+ * Return true if the two loops are interesting to merge, 
+ * otherwise return false.
+ */
+
+static bool
+loops_are_interesting_to_merge (struct loop * /*loop_first*/, struct loop * /*loop_next*/)
+{
+    //TODO
+    return true;
+}
+
+/* Performs legal loops fusion in the current function.  */
+
+static unsigned int
+tree_loop_fusion (void)
+{
+    //If there are no loops, no need to go farther
+    if (!current_loops)
+    {
+        return 0;
+    }
+
+    //Initialize the stats
+    memset (&fusion_stats, 0, sizeof (fusion_stats));
+   
+    if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+        fprintf (dump_file, "Start loop fusion pass\n");
+
+        flow_loops_dump (dump_file, NULL, 10);
+    }
+
+    struct loop *loop_first;
+    loop_iterator li;
+
+    //Consider only innermost loops, other cannot be merged with this strategy
+    FOR_EACH_LOOP (li, loop_first, LI_ONLY_INNERMOST)
+    {
+        //The algorithm cannot merge all loops
+        if (!loop_is_mergeable (loop_first))
+        {
+            if (dump_file && (dump_flags & TDF_DETAILS))
+            {
+                fprintf (dump_file, "Loop %d cannot be merged\n", 
+                        loop_first->num);
+            }
+
+            continue;
+        }
+
+        //Loop_first->next points to a loop in the same loop tree
+        if (loop_first->next)
+        {
+            struct loop *loop_next = loop_first->next;
+
+            gcc_assert (loop_outer (loop_first) == loop_outer (loop_next));
+
+            //The algorithm cannot merge all loops
+            if (!loop_is_mergeable (loop_next))
+            {
+                if (dump_file && (dump_flags & TDF_DETAILS))
+                {
+                    fprintf (dump_file, "Loop %d cannot be merged\n", 
+                            loop_next->num);
+                }
+
+                continue;
+            }
+
+            unsigned int index_first = bb_stream_index (loop_first->header);
+            unsigned int index_next  = bb_stream_index (loop_next->header);
+
+            //Order them so that the first is before the next in the instruction stream
+            if (index_first > index_next){
+                struct loop* tmp = loop_next;
+                loop_next = loop_first;
+                loop_first = tmp;
+            }
+
+            if (dump_file && (dump_flags & TDF_DETAILS))
+            {
+                fprintf (dump_file, "Consider Loops %d and %d as candidates\n", 
+                        loop_first->num, loop_next->num);
+            }
+
+            //Verify that the loops can be merged together
+            if (!loops_are_mergeable (loop_first, loop_next))
+            {
+                if (dump_file && (dump_flags & TDF_DETAILS))
+                {
+                    fprintf (dump_file, "Loops %d and %d cannot be merged\n", 
+                            loop_first->num, loop_next->num);
+                }
+
+                continue;
+            }
+                
+            //Finally, if they are interesting to merge, merge them
+            if (loops_are_interesting_to_merge (loop_first, loop_next))
+            {
+                fuse_loops (loop_first, loop_next);
+
+                //The cleanup remove empty basic blocks 
+                //to make further loop fusion possible
+                cleanup();
+            }
+        }
+    }
+    
+    //Update and verify the function is loops were fused
+    if (fusion_stats.fused > 0)
+    {
+        //The merging strategy does not take virtual operands into account
+        mark_virtual_operands_for_renaming (cfun);
+
+        //Make sure the function is transformed in LCSSA
+        rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);
+
+        //Update if necessary
+        update_ssa (TODO_update_ssa);
+
+        //Activate verification of the whole function
+        #ifdef ENABLE_CHECKING
+            verify_loop_structure ();
+            verify_gimple_in_cfg (cfun);
+            verify_ssa (true);
+        #endif
+    }
+  
+    //Add events for this pass 
+    statistics_counter_event (cfun, "Loop Fused", fusion_stats.fused);
+    statistics_counter_event (cfun, "Basic Blocks Merged", fusion_stats.merged);
+
+    return 0;
+}
+
+static bool
+gate_tree_loop_fusion (void)
+{
+    return flag_tree_loop_fusion != 0;
+}
+
+struct gimple_opt_pass pass_loop_fusion =
+{
+    {
+        GIMPLE_PASS, 
+        "lfusion",                      /* name */
+        gate_tree_loop_fusion,          /* gate */
+        tree_loop_fusion,               /* execute */
+        NULL,                           /* sub */
+        NULL,                           /* next */
+        0,                              /* static_pass_number */
+        TV_TREE_LOOP_FUSION,            /* tv_id */
+        PROP_cfg | PROP_ssa,            /* properties_required */
+        0,                              /* properties_provided */
+        0,                              /* properties_destroyed */
+        0,                              /* todo_flags_start */
+        TODO_update_ssa                 /* todo_flags_finish */ 
+      | TODO_verify_ssa
+      /*| TODO_rebuild_frequencies*/,   
+    }
+};
Index: gcc/opts.c
===================================================================
--- gcc/opts.c	(revision 192574)
+++ gcc/opts.c	(working copy)
@@ -487,6 +487,7 @@
     { OPT_LEVELS_2_PLUS, OPT_ftree_tail_merge, NULL, 1 },
     { OPT_LEVELS_2_PLUS_SPEED_ONLY, OPT_foptimize_strlen, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_fhoist_adjacent_loads, NULL, 1 },
+    { OPT_LEVELS_2_PLUS, OPT_ftree_loop_fusion, NULL, 1 },
 
     /* -O3 optimizations.  */
     { OPT_LEVELS_3_PLUS, OPT_ftree_loop_distribute_patterns, NULL, 1 },
Index: gcc/timevar.def
===================================================================
--- gcc/timevar.def	(revision 192574)
+++ gcc/timevar.def	(working copy)
@@ -171,6 +171,7 @@
 DEFTIMEVAR (TV_GRAPHITE_TRANSFORMS   , "Graphite loop transforms")
 DEFTIMEVAR (TV_GRAPHITE_DATA_DEPS    , "Graphite data dep analysis")
 DEFTIMEVAR (TV_GRAPHITE_CODE_GEN     , "Graphite code generation")
+DEFTIMEVAR (TV_TREE_LOOP_FUSION      , "tree loop fusion")
 DEFTIMEVAR (TV_TREE_LOOP_DISTRIBUTION, "tree loop distribution")
 DEFTIMEVAR (TV_CHECK_DATA_DEPS       , "tree check data dependences")
 DEFTIMEVAR (TV_TREE_PREFETCH	     , "tree prefetching")
Index: gcc/common.opt
===================================================================
--- gcc/common.opt	(revision 192574)
+++ gcc/common.opt	(working copy)
@@ -2050,6 +2050,10 @@
 Common Report Var(flag_optimize_strlen) Optimization
 Enable string length optimizations on trees
 
+ftree-loop-fusion
+Common Report Var(flag_tree_loop_fusion) Optimization
+Enable loop fusion on trees
+
 ftree-loop-distribution
 Common Report Var(flag_tree_loop_distribution) Optimization
 Enable loop distribution on trees
Index: gcc/Makefile.in
===================================================================
--- gcc/Makefile.in	(revision 192574)
+++ gcc/Makefile.in	(working copy)
@@ -1356,6 +1356,7 @@
 	tree-inline.o \
 	tree-into-ssa.o \
 	tree-iterator.o \
+    tree-loop-fusion.o \
 	tree-loop-distribution.o \
 	tree-nested.o \
 	tree-nomudflap.o \
@@ -2578,6 +2579,11 @@
    dumpfile.h $(TM_H) $(GGC_H) $(TREE_H) $(TREE_FLOW_H) \
    $(CFGLOOP_H) $(TREE_PASS_H) $(TREE_VECTORIZER_H) \
    $(TREE_PRETTY_PRINT_H)
+tree-loop-fusion.o: tree-loop-fusion.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \
+   $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \
+   tree-pass.h $(TREE_DATA_REF_H) $(SCEV_H) $(EXPR_H) \
+   $(TARGET_H) tree-chrec.h tree-vectorizer.h
 tree-loop-distribution.o: tree-loop-distribution.c $(CONFIG_H) $(SYSTEM_H) \
    coretypes.h $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) $(TREE_PASS_H)
 tree-parloops.o: tree-parloops.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
Index: gcc/passes.c
===================================================================
--- gcc/passes.c	(revision 192574)
+++ gcc/passes.c	(working copy)
@@ -1450,6 +1450,7 @@
 	  NEXT_PASS (pass_scev_cprop);
 	  NEXT_PASS (pass_record_bounds);
 	  NEXT_PASS (pass_check_data_deps);
+     NEXT_PASS (pass_loop_fusion);
 	  NEXT_PASS (pass_loop_distribution);
 	  NEXT_PASS (pass_copy_prop);
 	  NEXT_PASS (pass_graphite);

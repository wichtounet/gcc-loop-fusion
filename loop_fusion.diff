Index: gcc/doc/invoke.texi
===================================================================
--- gcc/doc/invoke.texi	(revision 192574)
+++ gcc/doc/invoke.texi	(working copy)
@@ -414,6 +414,7 @@
 -ftree-forwprop -ftree-fre -ftree-loop-if-convert @gol
 -ftree-loop-if-convert-stores -ftree-loop-im @gol
 -ftree-phiprop -ftree-loop-distribution -ftree-loop-distribute-patterns @gol
+-ftree-loop-fusion @gol
 -ftree-loop-ivcanon -ftree-loop-linear -ftree-loop-optimize @gol
 -ftree-parallelize-loops=@var{n} -ftree-pre -ftree-partial-pre -ftree-pta @gol
 -ftree-reassoc -ftree-sink -ftree-slsr -ftree-sra @gol
@@ -6418,6 +6419,7 @@
 -fstrict-aliasing -fstrict-overflow @gol
 -ftree-switch-conversion -ftree-tail-merge @gol
 -ftree-pre @gol
+-ftree-loop-fusion @gol
 -ftree-vrp}
 
 Please note the warning under @option{-fgcse} about
@@ -7534,6 +7536,11 @@
 @end smallexample
 potentially producing data races.
 
+@item -ftree-loop-fusion
+Perform loop fusion. This flag can improve cache performance on loops
+iterating through the same arrays.
+Enabled at level @option{-O2} and higher.
+
 @item -ftree-loop-distribution
 Perform loop distribution.  This flag can improve cache performance on
 big loop bodies and allow further loop optimizations, like
Index: gcc/tree-pass.h
===================================================================
--- gcc/tree-pass.h	(revision 192574)
+++ gcc/tree-pass.h	(working copy)
@@ -281,6 +281,7 @@
 extern struct gimple_opt_pass pass_graphite;
 extern struct gimple_opt_pass pass_graphite_transforms;
 extern struct gimple_opt_pass pass_if_conversion;
+extern struct gimple_opt_pass pass_loop_fusion; 
 extern struct gimple_opt_pass pass_loop_distribution;
 extern struct gimple_opt_pass pass_vectorize;
 extern struct gimple_opt_pass pass_slp_vectorize;
Index: gcc/testsuite/gcc.dg/autopar/autopar.exp
===================================================================
--- gcc/testsuite/gcc.dg/autopar/autopar.exp	(revision 192574)
+++ gcc/testsuite/gcc.dg/autopar/autopar.exp	(working copy)
@@ -29,6 +29,9 @@
     set DEFAULT_CFLAGS " -ansi -pedantic-errors"
 }
 
+# Loop Fusion has to be disabled for the tests
+lappend DEFAULT_CFLAGS "-fno-tree-loop-fusion"
+
 # Initialize `dg'.
 dg-init
 
Index: gcc/testsuite/gcc.dg/tree-ssa/lfusion-1.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/lfusion-1.c	(revision 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/lfusion-1.c	(revision 0)
@@ -0,0 +1,22 @@
+/* { dg-do compile } */ 
+/* { dg-options "-O2 -ftree-loop-fusion -fdump-tree-lfusion-all" } */
+
+void loop(int * __restrict__ ia){
+    unsigned int array[100];
+    unsigned int sum = 0;
+    
+    unsigned int i;
+    for(i = 0; i < 100; ++i){
+        array[i] = i;
+    }
+    
+    unsigned int j;
+    for(j = 0; j < 100; ++j){
+        sum += array[j];
+    }
+
+    *ia = sum;
+}
+
+/* { dg-final { scan-tree-dump-times "Loop Fused: 1" 1 "lfusion" } } */
+/* { dg-final { cleanup-tree-dump "lfusion" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/lfusion-2.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/lfusion-2.c	(revision 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/lfusion-2.c	(revision 0)
@@ -0,0 +1,29 @@
+/* { dg-do compile } */ 
+/* { dg-options "-O2 -ftree-loop-fusion -fdump-tree-lfusion-all" } */
+
+void loop(int * __restrict__ ia, int * __restrict__ ib){
+    unsigned int array1[100];
+    unsigned int array2[100];
+    unsigned int sum = 0;
+    
+    unsigned int i;
+    for(i = 0; i < 100; ++i){
+        array1[i] = i;
+    }
+    
+    unsigned int k;
+    for(k = 0; k < 100; ++k){
+        array2[k] = array1[k];
+    }
+
+    unsigned int j;
+    for(j = 0; j < 100; ++j){
+        sum += array1[j];
+    }
+
+    *ia = sum;
+    *ib = array2[99];
+}
+
+/* { dg-final { scan-tree-dump-times "Loop Fused: 2" 1 "lfusion" } } */
+/* { dg-final { cleanup-tree-dump "lfusion" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/lfusion-3.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/lfusion-3.c	(revision 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/lfusion-3.c	(revision 0)
@@ -0,0 +1,30 @@
+/* { dg-do compile } */ 
+/* { dg-options "-O2 -ftree-loop-fusion -fdump-tree-lfusion-all" } */
+
+void loop(int * __restrict__ ia){
+    unsigned int array[100];
+    unsigned int sum = 0;
+        
+    unsigned int i;
+    for(i = 0; i < 100; ++i){
+        array[i] = i;
+    }
+    
+    unsigned int j;
+    for(j = 0; j < 10; ++j){
+        unsigned int k;
+        for(k = 0; k < 100; ++k){
+            sum += array[k];
+        }
+
+        unsigned l;
+        for(l = 0; l < 100; ++l){
+            sum += array[l];
+        }
+    }
+
+    *ia = sum;
+}
+
+/* { dg-final { scan-tree-dump-times "Loop Fused: " 0 "lfusion" } } */
+/* { dg-final { cleanup-tree-dump "lfusion" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/lfusion-4.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/lfusion-4.c	(revision 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/lfusion-4.c	(revision 0)
@@ -0,0 +1,34 @@
+/* { dg-do compile } */ 
+/* { dg-options "-O2 -ftree-loop-fusion -fdump-tree-lfusion-all" } */
+
+void loop(int * __restrict__ ia){
+    unsigned int array1[100];
+    unsigned int array2[100];
+    unsigned int array3[100];
+    unsigned int array4[100];
+    
+    unsigned int i;
+    for(i = 0; i < 100; ++i){
+        array1[i] = i;
+    }
+    
+    unsigned int j;
+    for(j = 0; j < 100; ++j){
+        array2[j] = array1[j];
+    }
+    
+    unsigned int k;
+    for(k = 0; k < 100; ++k){
+        array3[k] = array2[k];
+    }
+    
+    unsigned int l;
+    for(l = 0; l < 100; ++l){
+        array4[l] = array3[l];
+    }
+
+    *ia = array4[99];
+}
+
+/* { dg-final { scan-tree-dump-times "Loop Fused: 3" 1 "lfusion" } } */
+/* { dg-final { cleanup-tree-dump "lfusion" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/lfusion-5.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/lfusion-5.c	(revision 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/lfusion-5.c	(revision 0)
@@ -0,0 +1,23 @@
+/* { dg-do compile } */ 
+/* { dg-options "-O2 -ftree-loop-fusion -fdump-tree-lfusion-all" } */
+
+void loop(int * __restrict__ ia, int * __restrict__ ib){
+    unsigned int A[100];
+    unsigned int B[100];
+    
+    unsigned int i;
+    for(i = 0; i < 100; ++i){
+        A[i] = 2;
+    }
+
+    unsigned int j;
+    for(j = 0; j < 100; ++j){
+        B[j] = 1 + A[j + 1];
+    }
+
+    *ia = A[99];
+    *ib = B[99];
+}
+
+/* { dg-final { scan-tree-dump-times "Loop Fused: " 0 "lfusion" } } */
+/* { dg-final { cleanup-tree-dump "lfusion" } } */
Index: gcc/testsuite/gcc.dg/vect/vect.exp
===================================================================
--- gcc/testsuite/gcc.dg/vect/vect.exp	(revision 192574)
+++ gcc/testsuite/gcc.dg/vect/vect.exp	(working copy)
@@ -42,6 +42,9 @@
 # These flags are used for all targets.
 lappend DEFAULT_VECTCFLAGS "-ftree-vectorize" "-fno-vect-cost-model" "-fno-common"
 
+# Loop Fusion has to be disabled for the tests
+lappend DEFAULT_VECTCFLAGS "-fno-tree-loop-fusion"
+
 # Initialize `dg'.
 dg-init
 
Index: gcc/tree-loop-fusion.c
===================================================================
--- gcc/tree-loop-fusion.c	(revision 0)
+++ gcc/tree-loop-fusion.c	(revision 0)
@@ -0,0 +1,952 @@
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tree.h"
+
+#include "basic-block.h"
+#include "tree-flow.h"
+#include "tree-dump.h"
+#include "timevar.h"
+#include "cfgloop.h"
+#include "tree-chrec.h"
+#include "tree-data-ref.h"
+#include "tree-scalar-evolution.h"
+#include "tree-pass.h"
+
+#include <iostream>
+
+/* 
+   This pass performs loop fusion: for example, the loops
+
+   |DO I = 1, N
+   |    A(I) = I
+   |ENDDO
+   
+   |DO I = 1, N
+   |    B(I) = A(I)
+   |ENDDO
+
+   will be transformed to
+
+   |DO I = 1, N
+   |    A(I) = I
+   |    B(I) = A(I)
+   |ENDDO
+
+*/
+
+static struct
+{
+  /* The number of loops fused. */
+  int fused;
+
+  /* The number of basic blocks merged during the cleanup pass */
+  int merged;
+
+} fusion_stats;
+
+/* Print a debug message if logging is enabled */
+
+static void
+print (const char* message)
+{
+    if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+        fprintf (dump_file, message);
+    }
+}
+
+/* 
+ * Print the current function to to the dump file 
+ * if logging is enabled. 
+ */
+
+static void 
+full_debug (const char* state)
+{
+    if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+        fprintf (dump_file, state);
+        dump_function_to_file (current_function_decl, dump_file, dump_flags);
+    }
+}
+
+/* Return the last BB (last in the instruction stream) */
+
+static basic_block 
+get_last_bb (struct loop *loop)
+{
+    basic_block header = loop->header;
+    basic_block latch = loop->latch;
+
+    if (header->next_bb == latch)
+    {
+       return latch; 
+    } 
+    else 
+    {
+        return header;
+    }
+}
+
+/* Return the first BB (first in the instruction stream) */
+
+static basic_block 
+get_first_bb (struct loop *loop)
+{
+    basic_block header = loop->header;
+    basic_block latch = loop->latch;
+
+    if (header->next_bb == latch)
+    {
+       return header; 
+    } 
+    else 
+    {
+        return latch;
+    }
+}
+
+/* Return the number of basic blocks between the two loops */
+
+static unsigned int
+distance_between_loops (struct loop *loop_first, struct loop *loop_next)
+{
+    //Some loops appears to have their latch first, so taking latch and header
+    //is not enough to determine the distance
+    basic_block current = get_last_bb (loop_first);
+    basic_block header_next = get_first_bb (loop_next);
+
+    unsigned int distance = 0;
+
+    while (current->next_bb != header_next)
+    {
+        ++distance;
+        current = current->next_bb;
+    }
+
+    return distance;
+}
+
+/* 
+ * Return the basic block between the two loops. 
+ * Assumes that the distance between the loops is 1. 
+ */
+
+static basic_block
+basic_block_between (struct loop *loop_first, struct loop* loop_next)
+{
+    //Some loops appears to have their latch first, so taking latch and header
+    //is not enough to determine the distance
+    basic_block last_bb = get_last_bb (loop_first);
+
+    basic_block between_bb = last_bb->next_bb;
+
+    gcc_assert (between_bb->next_bb == get_first_bb (loop_next));
+
+    return between_bb;
+}
+
+/* Return the induction variable SSA name for this loop */
+
+static tree 
+get_ssa_name_iv (struct loop* loop)
+{
+    tree ssa_iv_name = NULL_TREE;
+
+    for (gimple_stmt_iterator gsi = gsi_start_bb (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))
+    {
+        gimple stmt = gsi_stmt (gsi);
+
+        if (gimple_code (stmt) == GIMPLE_COND)
+        {
+            tree lhs = gimple_cond_lhs (stmt);
+            tree rhs = gimple_cond_rhs (stmt);
+
+            if (TREE_CODE (lhs) == SSA_NAME)
+            {
+                ssa_iv_name = lhs;
+            }
+            else if (TREE_CODE (rhs) == SSA_NAME)
+            {
+                ssa_iv_name = rhs;
+            } 
+        }
+    }
+
+    gcc_assert (ssa_iv_name != NULL_TREE);
+
+    return ssa_iv_name;
+}
+
+/* Return the PHI LHS for the given SSA name in the given loop */
+
+static tree 
+get_phi_var_for_iv(struct loop *loop, tree ssa_iv_name)
+{
+    tree def = NULL_TREE;
+    
+    for (gimple_stmt_iterator gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))
+    {
+        gimple phi = gsi_stmt (gsi);
+        
+        if (SSA_NAME_VAR (gimple_phi_result (phi)) == SSA_NAME_VAR (ssa_iv_name))
+        {
+            def = gimple_phi_result (phi);
+            break;
+        }
+    }
+    
+    gcc_assert (def != NULL_TREE);
+
+    return def;
+}
+
+/* 
+ * This function fuses two loops together 
+ *
+ * The two functions have to be mergeable and mergeable together 
+ * before this function is called. 
+ */
+
+static void
+fuse_loops (struct loop* loop_first, struct loop* loop_next)
+{
+    if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+        fprintf (dump_file, "Fusion of A=%d and B=%d\n", loop_first->num, loop_next->num);
+        full_debug ("Before fusion\n");
+    }
+
+    /* 1. Replace the induction variable */
+
+    tree ssa_iv_name_first = get_ssa_name_iv (loop_first);
+    tree ssa_iv_name_next = get_ssa_name_iv (loop_next);
+    
+    tree use = get_phi_var_for_iv (loop_first, ssa_iv_name_first);
+    tree def = get_phi_var_for_iv (loop_next, ssa_iv_name_next);
+    
+    replace_uses_by (def, use);
+    
+    full_debug ("After IV replacing\n");
+
+    /* 2. Transfer other PHI nodes */
+
+    edge old_entry_edge = loop_preheader_edge (loop_next);
+    edge old_latch_edge = loop_latch_edge (loop_next);
+    
+    edge new_entry_edge = loop_preheader_edge (loop_first);
+    edge new_latch_edge = loop_latch_edge (loop_first);
+    
+    for (gimple_stmt_iterator gsi = gsi_start_phis (loop_next->header); 
+            !gsi_end_p (gsi); )
+    {
+        gimple phi_orig = gsi_stmt (gsi);
+        tree result = gimple_phi_result ( phi_orig);
+        
+        if (SSA_NAME_VAR (result) != SSA_NAME_VAR (ssa_iv_name_next))
+        {
+            print ("Found a PHI node to copy \n");
+
+            gimple phi_new = create_phi_node (result, loop_first->header);
+        
+            tree def;
+            source_location locus;
+
+            /* Copy the first PHI arg (coming from entry) */
+            def = PHI_ARG_DEF_FROM_EDGE (phi_orig, old_entry_edge);
+            locus = gimple_phi_arg_location_from_edge (phi_orig, old_entry_edge);
+            add_phi_arg (phi_new, def, new_entry_edge, locus);
+            
+            /* Copy the second PHI arg (coming from the latch) */
+            def = PHI_ARG_DEF_FROM_EDGE (phi_orig, old_latch_edge);
+            locus = gimple_phi_arg_location_from_edge (phi_orig, old_latch_edge);
+            add_phi_arg (phi_new, def, new_latch_edge, locus);
+
+            //We do not want the SSA name to be released
+            remove_phi_node (&gsi, false);
+        } 
+        else 
+        {
+            //The SSA name can be released
+            remove_phi_node (&gsi, true);
+        }
+    }
+    
+    full_debug ("After transfer of PHI nodes\n");
+
+    /* 3. Transfer all the statements */
+    
+    gimple_stmt_iterator gsi_first_last = gsi_last_bb (loop_first->header);
+    gsi_prev (&gsi_first_last);
+
+    for (gimple_stmt_iterator gsi = gsi_start_bb (loop_next->header); 
+            !gsi_end_p (gsi);)
+    {
+        gimple stmt = gsi_stmt (gsi);
+
+        if (gimple_code(stmt) != GIMPLE_COND)
+        {
+            update_stmt (stmt);
+            gsi_move_before (&gsi, &gsi_first_last);
+            update_stmt (stmt);
+        }
+        else
+        {
+            gsi_next (&gsi);
+        }
+    }
+    
+    full_debug ("After transfer of statements\n");
+
+    /* 5. Delete the loop A */
+    
+    //Save them before loop gets deleted
+    basic_block between_bb = basic_block_between (loop_first, loop_next);
+    basic_block header_next = loop_next->header;
+    basic_block latch_next = loop_next->latch;
+    basic_block next_bb = get_last_bb (loop_next)->next_bb;
+    
+    //Move header_next and latch_next in the outer loop
+    remove_bb_from_loops (header_next);
+    add_bb_to_loop (header_next, loop_outer (loop_first));
+    
+    remove_bb_from_loops (latch_next);
+    add_bb_to_loop (latch_next, loop_outer (loop_first));
+    
+    delete_loop(loop_next);
+        
+    delete_basic_block(latch_next);
+        
+    full_debug ("After removing the loop\n");
+
+    /* 6. Fix edges */
+
+    //Fix the type of the edge
+    single_succ_edge (header_next)->flags |= EDGE_FALLTHRU;
+    single_succ_edge (header_next)->flags &= ~EDGE_TRUE_VALUE;
+    single_succ_edge (header_next)->flags &= ~EDGE_FALSE_VALUE;
+    
+    //Remove the condition from the old loop header
+    for (gimple_stmt_iterator gsi = gsi_start_bb (header_next); !gsi_end_p (gsi);)
+    {
+        gimple stmt = gsi_stmt (gsi);
+
+        if (gimple_code (stmt) == GIMPLE_COND)
+        {
+            gsi_remove (&gsi, true);
+        }
+        else
+        {
+            gsi_next (&gsi);
+        }
+    }
+    
+    full_debug ("After fixing the edges \n");
+
+    /* 7. Clean the basic blocks */
+
+    //Remove the between block if possible
+    if (gimple_seq_empty_p (phi_nodes (between_bb)) 
+            && gimple_seq_empty_p (bb_seq (between_bb)))
+    {
+        redirect_edge_and_branch (single_pred_edge (between_bb), header_next);
+
+        delete_basic_block (between_bb);
+    } 
+    else 
+    {
+        set_immediate_dominator (CDI_DOMINATORS, between_bb, 
+                recompute_dominator (CDI_DOMINATORS, between_bb));
+    }
+    
+    full_debug ("After cleaning basic blocks\n");
+
+    /* 7. Update SSA */
+
+    update_ssa (TODO_update_ssa);
+
+    /* 8. Update dominators */
+    
+    set_immediate_dominator (CDI_DOMINATORS, loop_first->header, 
+            recompute_dominator (CDI_DOMINATORS, loop_first->header));
+    set_immediate_dominator (CDI_DOMINATORS, loop_first->latch, 
+            recompute_dominator (CDI_DOMINATORS, loop_first->latch));
+    set_immediate_dominator (CDI_DOMINATORS, next_bb, 
+            recompute_dominator (CDI_DOMINATORS, next_bb));
+    set_immediate_dominator (CDI_DOMINATORS, header_next, 
+            recompute_dominator (CDI_DOMINATORS, header_next));
+
+    /* 9. Fix the profile information */
+
+    //TODO Restore the profile information
+    
+    full_debug ("After fusion\n");
+
+    ++fusion_stats.fused;
+}
+
+/* Indicates if the specified basic block can be merged */
+
+static bool
+dirty (basic_block bb)
+{
+    if (gimple_seq_empty_p (bb_seq (bb)) && gimple_seq_empty_p (phi_nodes (bb)))
+    {
+        return single_succ_p (bb) && single_pred_p (bb);
+    }
+
+    return false;
+}
+
+/* Tries to find basic blocks to be merged */
+
+static void
+cleanup ()
+{
+    basic_block bb;
+    
+    FOR_EACH_BB(bb)
+    {
+        if (dirty(bb))
+        {
+            basic_block bb_next = bb->next_bb;
+
+            if (bb_next && dirty (bb_next))
+            {
+                //They have to fall through the instruction stream
+                if (single_succ_edge (bb)->dest == bb_next)
+                {
+                    merge_blocks (bb, bb_next);
+                    
+                    ++fusion_stats.merged;
+                }
+            }
+        }
+    }
+}
+
+/* 
+ * Returns true if the access functions are equivalent, 
+ * the induction variable may vary. 
+ */
+
+static bool
+are_equivalent_functions (const_tree chrec0, const_tree chrec1)
+{
+    if (chrec0 == NULL_TREE || chrec1 == NULL_TREE 
+            || TREE_CODE (chrec0) != TREE_CODE (chrec1))
+    {
+        return false;
+    }
+
+    if (chrec0 == chrec1)
+    {
+        return true;
+    }
+
+    switch (TREE_CODE (chrec0))
+    {
+        case INTEGER_CST:
+            return operand_equal_p (chrec0, chrec1, 0);
+
+        case POLYNOMIAL_CHREC:
+            return eq_evolutions_p (CHREC_LEFT (chrec0), CHREC_LEFT (chrec1))
+                && eq_evolutions_p (CHREC_RIGHT (chrec0), CHREC_RIGHT (chrec1));
+
+        case PLUS_EXPR:
+        case MULT_EXPR:
+        case MINUS_EXPR:
+        case POINTER_PLUS_EXPR:
+            return eq_evolutions_p (TREE_OPERAND (chrec0, 0), TREE_OPERAND (chrec1, 0))
+                && eq_evolutions_p (TREE_OPERAND (chrec0, 1), TREE_OPERAND (chrec1, 1));
+
+        default:
+            return false;
+    }
+}
+
+/* 
+ * Returns true if both data references have equivalent access function, 
+ * the induction variable may change. 
+ */
+
+static bool
+are_equivalent (data_reference_p a, data_reference_p b)
+{
+    unsigned int i;
+
+    /* The references are exactly the same.  */
+    if (operand_equal_p (DR_REF (a), DR_REF (b), 0))
+    {
+        return true;
+    }
+
+    if (!same_data_refs_base_objects (a, b))
+    {
+        return false;
+    }
+
+    for (i = 0; i < DR_NUM_DIMENSIONS (a); i++)
+    {
+        if (!are_equivalent_functions (DR_ACCESS_FN (a, i), DR_ACCESS_FN (b, i)))
+        {
+            return false;
+        }
+    }
+
+    //TODO Verify the var of each data reference is the induction variable
+
+    return true;
+}
+
+/* Returns true if loops are independent. */
+
+static bool
+are_independent (struct loop *loop_first, struct loop *loop_next)
+{
+    VEC (data_reference_p, heap) *datarefs_next = 
+        VEC_alloc (data_reference_p, heap, 10);
+    VEC (data_reference_p, heap) *datarefs_first = 
+        VEC_alloc (data_reference_p, heap, 10);
+
+    VEC (ddr_p, heap) *dependence_relations_next = 
+        VEC_alloc (ddr_p, heap, 10 * 10);
+    VEC (ddr_p, heap) *dependence_relations_first = 
+        VEC_alloc (ddr_p, heap, 10 * 10);
+
+    VEC (loop_p, heap) *loop_nest_next = VEC_alloc (loop_p, heap, 3);
+    VEC (loop_p, heap) *loop_nest_first = VEC_alloc (loop_p, heap, 3);
+
+    bool success = true;
+    success &= compute_data_dependences_for_loop (loop_next, true, &loop_nest_next, 
+            &datarefs_next, &dependence_relations_next); 
+    success &= compute_data_dependences_for_loop (loop_first, true, &loop_nest_first, 
+            &datarefs_first, &dependence_relations_first);
+
+    //If the data dependence does not success, we consider the loops as dependent
+    bool ret = false;
+
+    if(!success)
+    {
+        print ("Data dependence analysis failed\n");
+    }
+    else
+    {
+        //If no dependences are found later, the loops are not dependent
+        ret = true;
+
+        data_reference_p ref_first;
+        data_reference_p ref_second;
+        unsigned int i;
+        unsigned int j;
+
+        //Dump data references
+        if (dump_file && (dump_flags & TDF_DETAILS))
+        {
+            fprintf (dump_file, "Print data reference of A\n");
+            FOR_EACH_VEC_ELT (data_reference_p, datarefs_first, i, ref_first)
+            {
+                if (!ref_first || !DR_STMT (ref_first))
+                {
+                    fprintf (dump_file, "Null data reference\n");
+                } 
+                else 
+                {
+                    dump_data_reference (dump_file, ref_first);
+                }
+            }
+
+            fprintf (dump_file, "Print data reference of B\n");
+            FOR_EACH_VEC_ELT (data_reference_p, datarefs_next, j, ref_second)
+            {
+                if (!ref_second || !DR_STMT (ref_second))
+                {
+                    fprintf (dump_file, "Null data reference\n");
+                } 
+                else 
+                {
+                    dump_data_reference (dump_file, ref_second);
+                }
+            }
+        }
+
+        //Consider each pair of dependences between the loops
+        FOR_EACH_VEC_ELT (data_reference_p, datarefs_first, i, ref_first)
+        {
+            //TODO Find what to do with these "NULL" references
+            if(!ref_first || !DR_STMT (ref_first))
+            {
+                print ("A and B are not independent due to unresolved dependences\n");
+                ret = false;
+                break;
+            }
+
+            FOR_EACH_VEC_ELT (data_reference_p, datarefs_next, j, ref_second)
+            {
+                //TODO Find what to do with these "NULL" references
+                if(!ref_second || !DR_STMT (ref_second))
+                {
+                    print ("A and B are not independent due to unresolved dependences\n");
+                    ret = false;
+                    break;
+                }
+
+                if (same_data_refs_base_objects (ref_first, ref_second))
+                {
+                    if (DR_IS_READ (ref_first) && DR_IS_READ (ref_second))
+                    {
+                        print ("Found an input-dependence\n");
+                        //Input reference can be ignored
+                    } 
+                    else if (DR_IS_WRITE (ref_first) && DR_IS_WRITE (ref_second))
+                    {
+                        print ("Found an output-dependence\n");
+
+                        if (!are_equivalent (ref_first, ref_second))
+                        {
+                            print ("An output-dependence is blocking\n");
+                            ret = false;
+                        }
+                    } 
+                    else if (DR_IS_READ (ref_first) && DR_IS_WRITE (ref_second))
+                    {
+                        print ("Found an anti-dependence\n");
+
+                        if (!are_equivalent (ref_first, ref_second))
+                        {
+                            print ("An anti-dependence is blocking\n");
+                            ret = false;
+                        }
+                    } 
+                    else if (DR_IS_WRITE (ref_first) && DR_IS_READ (ref_second))
+                    {
+                        print ("Found a true-dependence\n");
+
+                        if (!are_equivalent (ref_first, ref_second))
+                        {
+                            print ("A true-dependence is blocking\n");
+                            ret = false;
+                        }
+                    }
+                }
+            }
+
+            if(!ret){
+                break;
+            }
+        }
+    }
+
+    free_dependence_relations (dependence_relations_next);
+    free_dependence_relations (dependence_relations_first);
+
+    free_data_refs (datarefs_next);
+    free_data_refs (datarefs_first);
+
+    VEC_free (loop_p, heap, loop_nest_next);
+    VEC_free (loop_p, heap, loop_nest_first);
+
+    return ret;
+}
+
+/* Return the index of the basic block in the instruction stream */
+
+static unsigned int
+bb_stream_index (basic_block block)
+{
+    unsigned int index = 0;
+
+    basic_block bb;
+    FOR_EACH_BB (bb)
+    {
+        if(bb == block)
+        {
+            break;
+        }
+
+        ++index;
+    }
+
+    return index;
+}
+
+/* Verify if this loop is supported by the merging algorithm */
+
+static bool 
+loop_is_mergeable (struct loop* loop)
+{
+    //The algorithm will fail on loop with more than one exit
+    if (!single_exit (loop))
+    {
+        return false; 
+    }
+
+    //It is necessary to know the number of times a loop will iterate
+    if (!loop->any_estimate || !loop->any_upper_bound)
+    {
+        return false;
+    }
+    
+    //It is necessary to have a precise estimate
+    if (loop->nb_iterations_estimate != loop->nb_iterations_upper_bound)
+    {
+        return false;
+    }
+     
+    //The algorithm only supports loops with a header and a latch
+    if (loop->num_nodes > 2)
+    {
+        return false;
+    }
+    
+    tree ssa_iv_name = get_ssa_name_iv (loop);
+
+    //The Induction Variable is not of integer type
+    if(TREE_CODE(TREE_TYPE(ssa_iv_name)) != INTEGER_TYPE)
+    {
+        return false;
+    }
+    
+    basic_block header = loop->header;
+    basic_block latch = loop->latch;
+
+    //The header and the latch should be sibling in the instruction stream
+    if(!(header->next_bb == latch || latch->next_bb == header)){
+        return false;
+    }
+
+    return true;
+}
+
+/* Return true if the loops can be fused. Both loops have to be mergeable. */
+
+static bool
+loops_are_mergeable (struct loop *loop_first, struct loop *loop_next)
+{
+    //Both loop should iterate the same number of times
+    if (loop_next->nb_iterations_estimate != loop_first->nb_iterations_estimate)
+    {
+        return false;
+    }
+
+    //Only support loops with only one basic block between them
+    unsigned int distance = distance_between_loops (loop_first, loop_next);
+    if (distance != 1)
+    {
+        print ("The distance is too high\n");
+
+        return false;
+    }
+
+    basic_block between_bb = basic_block_between (loop_first, loop_next);
+
+    //The two loops must be always executed together
+    if (!single_succ_p (between_bb) || !single_pred_p (between_bb))
+    {
+        print ("The between block has too many predecessors or successors\n");
+
+        return false;
+    }
+
+    //Only empty block between A and B are supported
+    if (!gimple_seq_empty_p( bb_seq( between_bb)))
+    {
+        print ("Too many statements in the between block\n");
+
+        return false;
+    }
+
+    //Only empty block between A and B are supported
+    if (!gimple_seq_empty_p( phi_nodes( between_bb)))
+    {
+        print ("Too many PHI nodes in the between block\n");
+
+        return false;
+    }
+    
+    tree ssa_iv_name_first = get_ssa_name_iv (loop_first);
+    tree ssa_iv_name_next = get_ssa_name_iv (loop_next);
+
+    tree type_iv_first = TREE_TYPE(ssa_iv_name_first);
+    tree type_iv_next = TREE_TYPE(ssa_iv_name_next);
+
+    //The induction variables must be both signed or both unsigned
+    if((TYPE_UNSIGNED (type_iv_first) && !TYPE_UNSIGNED (type_iv_next)) 
+            || (!TYPE_UNSIGNED (type_iv_first) && TYPE_UNSIGNED (type_iv_next))){
+        return false;
+    }
+    
+    //The induction variables must of same precision
+    if(TYPE_PRECISION (type_iv_first) != TYPE_PRECISION (type_iv_next)){
+        return false;
+    }
+
+    //If all the other conditions are, 
+    //the loops needs only to be independent to be fused
+    return are_independent (loop_first, loop_next);
+}
+
+/* 
+ * Return true if the two loops are interesting to merge, 
+ * otherwise return false.
+ */
+
+static bool
+loops_are_interesting_to_merge (struct loop * /*loop_first*/, struct loop * /*loop_next*/)
+{
+    //TODO
+    return true;
+}
+
+/* Performs legal loops fusion in the current function.  */
+
+static unsigned int
+tree_loop_fusion (void)
+{
+    //If there are no loops, no need to go farther
+    if (!current_loops)
+    {
+        return 0;
+    }
+
+    //Initialize the stats
+    memset (&fusion_stats, 0, sizeof (fusion_stats));
+   
+    if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+        fprintf (dump_file, "Start loop fusion pass\n");
+
+        flow_loops_dump (dump_file, NULL, 10);
+    }
+
+    struct loop *loop_first;
+    loop_iterator li;
+
+    //Consider only innermost loops, other cannot be merged with this strategy
+    FOR_EACH_LOOP (li, loop_first, LI_ONLY_INNERMOST)
+    {
+        //The algorithm cannot merge all loops
+        if (!loop_is_mergeable (loop_first))
+        {
+            if (dump_file && (dump_flags & TDF_DETAILS))
+            {
+                fprintf (dump_file, "Loop %d cannot be merged\n", 
+                        loop_first->num);
+            }
+
+            continue;
+        }
+
+        //Loop_first->next points to a loop in the same loop tree
+        if (loop_first->next)
+        {
+            struct loop *loop_next = loop_first->next;
+
+            gcc_assert (loop_outer (loop_first) == loop_outer (loop_next));
+
+            //The algorithm cannot merge all loops
+            if (!loop_is_mergeable (loop_next))
+            {
+                if (dump_file && (dump_flags & TDF_DETAILS))
+                {
+                    fprintf (dump_file, "Loop %d cannot be merged\n", 
+                            loop_next->num);
+                }
+
+                continue;
+            }
+
+            unsigned int index_first = bb_stream_index (loop_first->header);
+            unsigned int index_next  = bb_stream_index (loop_next->header);
+
+            //Order them so that the first is before the next in the instruction stream
+            if(index_first > index_next){
+                struct loop* tmp = loop_next;
+                loop_next = loop_first;
+                loop_first = tmp;
+            }
+
+            if (dump_file && (dump_flags & TDF_DETAILS))
+            {
+                fprintf (dump_file, "Consider Loops %d and %d as candidates\n", 
+                        loop_first->num, loop_next->num);
+            }
+
+            //Verify that the loops can be merged together
+            if (!loops_are_mergeable (loop_first, loop_next))
+            {
+                if (dump_file && (dump_flags & TDF_DETAILS))
+                {
+                    fprintf (dump_file, "Loops %d and %d cannot be merged\n", 
+                            loop_first->num, loop_next->num);
+                }
+
+                continue;
+            }
+                
+            //Finally, if they are interesting to merge, merge them
+            if (loops_are_interesting_to_merge (loop_first, loop_next))
+            {
+                fuse_loops (loop_first, loop_next);
+
+                //The cleanup remove empty basic blocks 
+                //to make further loop fusion possible
+                cleanup();
+            }
+        }
+    }
+    
+    //Update and verify the function is loops were fused
+    if (fusion_stats.fused > 0)
+    {
+        //The merging strategy does not take virtual operands into account
+        mark_virtual_operands_for_renaming (cfun);
+
+        //Make sure the function is transformed in LCSSA
+        rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);
+
+        //Update if necessary
+        update_ssa (TODO_update_ssa);
+
+        //Activate verification of the whole function
+        #ifdef ENABLE_CHECKING
+            verify_loop_structure ();
+            verify_gimple_in_cfg (cfun);
+            verify_ssa (true);
+        #endif
+    }
+  
+    //Add events for this pass 
+    statistics_counter_event (cfun, "Loop Fused", fusion_stats.fused);
+    statistics_counter_event (cfun, "Basic Blocks Merged", fusion_stats.merged);
+
+    return 0;
+}
+
+static bool
+gate_tree_loop_fusion (void)
+{
+    return flag_tree_loop_fusion != 0;
+}
+
+struct gimple_opt_pass pass_loop_fusion =
+{
+    {
+        GIMPLE_PASS, 
+        "lfusion",                      /* name */
+        gate_tree_loop_fusion,          /* gate */
+        tree_loop_fusion,               /* execute */
+        NULL,                           /* sub */
+        NULL,                           /* next */
+        0,                              /* static_pass_number */
+        TV_TREE_LOOP_FUSION,            /* tv_id */
+        PROP_cfg | PROP_ssa,            /* properties_required */
+        0,                              /* properties_provided */
+        0,                              /* properties_destroyed */
+        0,                              /* todo_flags_start */
+        TODO_update_ssa                 /* todo_flags_finish */ 
+      | TODO_verify_ssa
+      /*| TODO_rebuild_frequencies*/,   
+    }
+};
Index: gcc/opts.c
===================================================================
--- gcc/opts.c	(revision 192574)
+++ gcc/opts.c	(working copy)
@@ -487,6 +487,7 @@
     { OPT_LEVELS_2_PLUS, OPT_ftree_tail_merge, NULL, 1 },
     { OPT_LEVELS_2_PLUS_SPEED_ONLY, OPT_foptimize_strlen, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_fhoist_adjacent_loads, NULL, 1 },
+    { OPT_LEVELS_2_PLUS, OPT_ftree_loop_fusion, NULL, 1 },
 
     /* -O3 optimizations.  */
     { OPT_LEVELS_3_PLUS, OPT_ftree_loop_distribute_patterns, NULL, 1 },
Index: gcc/timevar.def
===================================================================
--- gcc/timevar.def	(revision 192574)
+++ gcc/timevar.def	(working copy)
@@ -171,6 +171,7 @@
 DEFTIMEVAR (TV_GRAPHITE_TRANSFORMS   , "Graphite loop transforms")
 DEFTIMEVAR (TV_GRAPHITE_DATA_DEPS    , "Graphite data dep analysis")
 DEFTIMEVAR (TV_GRAPHITE_CODE_GEN     , "Graphite code generation")
+DEFTIMEVAR (TV_TREE_LOOP_FUSION      , "tree loop fusion")
 DEFTIMEVAR (TV_TREE_LOOP_DISTRIBUTION, "tree loop distribution")
 DEFTIMEVAR (TV_CHECK_DATA_DEPS       , "tree check data dependences")
 DEFTIMEVAR (TV_TREE_PREFETCH	     , "tree prefetching")
Index: gcc/common.opt
===================================================================
--- gcc/common.opt	(revision 192574)
+++ gcc/common.opt	(working copy)
@@ -2050,6 +2050,10 @@
 Common Report Var(flag_optimize_strlen) Optimization
 Enable string length optimizations on trees
 
+ftree-loop-fusion
+Common Report Var(flag_tree_loop_fusion) Optimization
+Enable loop fusion on trees
+
 ftree-loop-distribution
 Common Report Var(flag_tree_loop_distribution) Optimization
 Enable loop distribution on trees
Index: gcc/Makefile.in
===================================================================
--- gcc/Makefile.in	(revision 192574)
+++ gcc/Makefile.in	(working copy)
@@ -1356,6 +1356,7 @@
 	tree-inline.o \
 	tree-into-ssa.o \
 	tree-iterator.o \
+    tree-loop-fusion.o \
 	tree-loop-distribution.o \
 	tree-nested.o \
 	tree-nomudflap.o \
@@ -2578,6 +2579,11 @@
    dumpfile.h $(TM_H) $(GGC_H) $(TREE_H) $(TREE_FLOW_H) \
    $(CFGLOOP_H) $(TREE_PASS_H) $(TREE_VECTORIZER_H) \
    $(TREE_PRETTY_PRINT_H)
+tree-loop-fusion.o: tree-loop-fusion.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \
+   $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \
+   tree-pass.h $(TREE_DATA_REF_H) $(SCEV_H) $(EXPR_H) \
+   $(TARGET_H) tree-chrec.h tree-vectorizer.h
 tree-loop-distribution.o: tree-loop-distribution.c $(CONFIG_H) $(SYSTEM_H) \
    coretypes.h $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) $(TREE_PASS_H)
 tree-parloops.o: tree-parloops.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
Index: gcc/passes.c
===================================================================
--- gcc/passes.c	(revision 192574)
+++ gcc/passes.c	(working copy)
@@ -1450,6 +1450,7 @@
 	  NEXT_PASS (pass_scev_cprop);
 	  NEXT_PASS (pass_record_bounds);
 	  NEXT_PASS (pass_check_data_deps);
+     NEXT_PASS (pass_loop_fusion);
 	  NEXT_PASS (pass_loop_distribution);
 	  NEXT_PASS (pass_copy_prop);
 	  NEXT_PASS (pass_graphite);

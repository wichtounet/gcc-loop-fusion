Index: gcc/doc/invoke.texi
===================================================================
--- gcc/doc/invoke.texi	(revision 192697)
+++ gcc/doc/invoke.texi	(working copy)
@@ -414,6 +414,7 @@
 -ftree-forwprop -ftree-fre -ftree-loop-if-convert @gol
 -ftree-loop-if-convert-stores -ftree-loop-im @gol
 -ftree-phiprop -ftree-loop-distribution -ftree-loop-distribute-patterns @gol
+-ftree-loop-fusion @gol
 -ftree-loop-ivcanon -ftree-loop-linear -ftree-loop-optimize @gol
 -ftree-parallelize-loops=@var{n} -ftree-pre -ftree-partial-pre -ftree-pta @gol
 -ftree-reassoc -ftree-sink -ftree-slsr -ftree-sra @gol
@@ -6418,6 +6419,7 @@
 -fstrict-aliasing -fstrict-overflow @gol
 -ftree-switch-conversion -ftree-tail-merge @gol
 -ftree-pre @gol
+-ftree-loop-fusion @gol
 -ftree-vrp}
 
 Please note the warning under @option{-fgcse} about
@@ -7542,6 +7544,11 @@
 @end smallexample
 potentially producing data races.
 
+@item -ftree-loop-fusion
+Perform loop fusion. This flag can improve cache performance on loops
+iterating through the same arrays.
+Enabled at level @option{-O2} and higher.
+
 @item -ftree-loop-distribution
 Perform loop distribution.  This flag can improve cache performance on
 big loop bodies and allow further loop optimizations, like
Index: gcc/tree-pass.h
===================================================================
--- gcc/tree-pass.h	(revision 192697)
+++ gcc/tree-pass.h	(working copy)
@@ -281,6 +281,7 @@
 extern struct gimple_opt_pass pass_graphite;
 extern struct gimple_opt_pass pass_graphite_transforms;
 extern struct gimple_opt_pass pass_if_conversion;
+extern struct gimple_opt_pass pass_loop_fusion; 
 extern struct gimple_opt_pass pass_loop_distribution;
 extern struct gimple_opt_pass pass_vectorize;
 extern struct gimple_opt_pass pass_slp_vectorize;
Index: gcc/testsuite/gfortran.dg/vect/vect.exp
===================================================================
--- gcc/testsuite/gfortran.dg/vect/vect.exp	(revision 192697)
+++ gcc/testsuite/gfortran.dg/vect/vect.exp	(working copy)
@@ -28,6 +28,9 @@
 lappend DEFAULT_VECTCFLAGS "-O2" "-ftree-vectorize" "-fno-vect-cost-model" \
   "-fdump-tree-vect-details"
 
+# Disable Loop Fusion
+lappend DEFAULT_VECTCFLAGS "-fno-tree-loop-fusion" 
+
 # If the target system supports vector instructions, the default action
 # for a test is 'run', otherwise it's 'compile'.  Save current default.
 # Executing vector instructions on a system without hardware vector support
Index: gcc/testsuite/gcc.dg/autopar/reduc-6.c
===================================================================
--- gcc/testsuite/gcc.dg/autopar/reduc-6.c	(revision 192697)
+++ gcc/testsuite/gcc.dg/autopar/reduc-6.c	(working copy)
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized" } */
+/* { dg-options "-O2 -fno-tree-loop-fusion -ftree-parallelize-loops=4 -fdump-tree-parloops-details -fdump-tree-optimized" } */
 
 #include <stdarg.h>
 #include <stdlib.h>
Index: gcc/testsuite/gcc.dg/tree-ssa/lfusion-1.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/lfusion-1.c	(revision 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/lfusion-1.c	(revision 0)
@@ -0,0 +1,24 @@
+/* { dg-do compile } */ 
+/* { dg-options "-O2 -ftree-loop-fusion -fdump-tree-lfusion-all" } */
+
+#define SIZE 1000
+
+void loop(int * __restrict__ ia){
+    unsigned int array[SIZE];
+    unsigned int sum = 0;
+    
+    unsigned int i;
+    for(i = 0; i < SIZE; ++i){
+        array[i] = i;
+    }
+    
+    unsigned int j;
+    for(j = 0; j < SIZE; ++j){
+        sum += array[j];
+    }
+
+    *ia = sum;
+}
+
+/* { dg-final { scan-tree-dump-times "Loop Fused: 1" 1 "lfusion" } } */
+/* { dg-final { cleanup-tree-dump "lfusion" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/lfusion-2.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/lfusion-2.c	(revision 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/lfusion-2.c	(revision 0)
@@ -0,0 +1,31 @@
+/* { dg-do compile } */ 
+/* { dg-options "-O2 -ftree-loop-fusion -fdump-tree-lfusion-all" } */
+
+#define SIZE 1000
+
+void loop(int * __restrict__ ia, int * __restrict__ ib){
+    unsigned int array1[SIZE];
+    unsigned int array2[SIZE];
+    unsigned int sum = 0;
+    
+    unsigned int i;
+    for(i = 0; i < SIZE; ++i){
+        array1[i] = i;
+    }
+    
+    unsigned int k;
+    for(k = 0; k < SIZE; ++k){
+        array2[k] = array1[k];
+    }
+
+    unsigned int j;
+    for(j = 0; j < SIZE; ++j){
+        sum += array1[j];
+    }
+
+    *ia = sum;
+    *ib = array2[SIZE - 1];
+}
+
+/* { dg-final { scan-tree-dump-times "Loop Fused: 2" 1 "lfusion" } } */
+/* { dg-final { cleanup-tree-dump "lfusion" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/lfusion-3.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/lfusion-3.c	(revision 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/lfusion-3.c	(revision 0)
@@ -0,0 +1,32 @@
+/* { dg-do compile } */ 
+/* { dg-options "-O2 -ftree-loop-fusion -fdump-tree-lfusion-all" } */
+
+#define SIZE 1000
+
+void loop(int * __restrict__ ia){
+    unsigned int array[SIZE];
+    unsigned int sum = 0;
+        
+    unsigned int i;
+    for(i = 0; i < SIZE; ++i){
+        array[i] = i;
+    }
+    
+    unsigned int j;
+    for(j = 0; j < 10; ++j){
+        unsigned int k;
+        for(k = 0; k < SIZE; ++k){
+            sum += array[k];
+        }
+
+        unsigned l;
+        for(l = 0; l < SIZE; ++l){
+            sum += array[l];
+        }
+    }
+
+    *ia = sum;
+}
+
+/* { dg-final { scan-tree-dump-times "Loop Fused: " 0 "lfusion" } } */
+/* { dg-final { cleanup-tree-dump "lfusion" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/lfusion-4.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/lfusion-4.c	(revision 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/lfusion-4.c	(revision 0)
@@ -0,0 +1,36 @@
+/* { dg-do compile } */ 
+/* { dg-options "-O2 -ftree-loop-fusion -fdump-tree-lfusion-all" } */
+
+#define SIZE 1000
+
+void loop(int * __restrict__ ia){
+    unsigned int array1[SIZE];
+    unsigned int array2[SIZE];
+    unsigned int array3[SIZE];
+    unsigned int array4[SIZE];
+    
+    unsigned int i;
+    for(i = 0; i < SIZE; ++i){
+        array1[i] = i;
+    }
+    
+    unsigned int j;
+    for(j = 0; j < SIZE; ++j){
+        array2[j] = array1[j];
+    }
+    
+    unsigned int k;
+    for(k = 0; k < SIZE; ++k){
+        array3[k] = array2[k];
+    }
+    
+    unsigned int l;
+    for(l = 0; l < SIZE; ++l){
+        array4[l] = array3[l];
+    }
+
+    *ia = array4[SIZE - 1];
+}
+
+/* { dg-final { scan-tree-dump-times "Loop Fused: 3" 1 "lfusion" } } */
+/* { dg-final { cleanup-tree-dump "lfusion" } } */
Index: gcc/testsuite/gcc.dg/tree-ssa/lfusion-5.c
===================================================================
--- gcc/testsuite/gcc.dg/tree-ssa/lfusion-5.c	(revision 0)
+++ gcc/testsuite/gcc.dg/tree-ssa/lfusion-5.c	(revision 0)
@@ -0,0 +1,25 @@
+/* { dg-do compile } */ 
+/* { dg-options "-O2 -ftree-loop-fusion -fdump-tree-lfusion-all" } */
+
+#define SIZE 1000
+
+void loop(int * __restrict__ ia, int * __restrict__ ib){
+    unsigned int A[SIZE];
+    unsigned int B[SIZE];
+    
+    unsigned int i;
+    for(i = 0; i < SIZE; ++i){
+        A[i] = 2;
+    }
+
+    unsigned int j;
+    for(j = 0; j < SIZE; ++j){
+        B[j] = 1 + A[j + 1];
+    }
+
+    *ia = A[SIZE - 1];
+    *ib = B[SIZE - 1];
+}
+
+/* { dg-final { scan-tree-dump-times "Loop Fused: " 0 "lfusion" } } */
+/* { dg-final { cleanup-tree-dump "lfusion" } } */
Index: gcc/testsuite/gcc.dg/vect/vect.exp
===================================================================
--- gcc/testsuite/gcc.dg/vect/vect.exp	(revision 192697)
+++ gcc/testsuite/gcc.dg/vect/vect.exp	(working copy)
@@ -42,6 +42,9 @@
 # These flags are used for all targets.
 lappend DEFAULT_VECTCFLAGS "-ftree-vectorize" "-fno-vect-cost-model" "-fno-common"
 
+# Loop Fusion has to be disabled for the tests
+lappend DEFAULT_VECTCFLAGS "-fno-tree-loop-fusion"
+
 # Initialize `dg'.
 dg-init

Index: gcc/tree-loop-fusion.c
===================================================================
--- gcc/tree-loop-fusion.c	(revision 0)
+++ gcc/tree-loop-fusion.c	(working copy)
@@ -0,0 +1,1245 @@
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tree.h"
+#include "basic-block.h"
+#include "tree-flow.h"
+#include "tree-dump.h"
+#include "timevar.h"
+#include "cfgloop.h"
+#include "tree-chrec.h"
+#include "tree-data-ref.h"
+#include "tree-scalar-evolution.h"
+#include "tree-pass.h"
+#include "tree-ssa-alias.h"
+
+/* 
+   This pass performs loop fusion: for example, the loops
+
+   |FOR i = 1...100
+   |   A[i] = i
+   |ENDFOR
+
+   |FOR i = 1...100
+   |   B[i] = A[i]
+   |ENDFOR
+
+   will be transformed to
+
+   |FOR i = 1...100
+   |   A[i] = i
+   |   B[i] = A[i]
+   |ENDFOR
+
+   resulting in less cache misses by iterations. 
+
+*/
+
+/* Defined in tree-parloops.c */
+
+extern bool
+loop_parallel_p (struct loop *loop, struct obstack * parloop_obstack);
+
+/* Return true if a loop is parallel. */
+
+static bool
+parallel_p (struct loop* loop)
+{
+    struct obstack parloop_obstack;
+    gcc_obstack_init (&parloop_obstack);
+
+    bool parallel = loop_parallel_p (loop, &parloop_obstack);
+
+    obstack_free (&parloop_obstack, NULL);
+
+    return parallel;
+}
+
+/* Return true if a loop is sequential. */
+
+static bool
+loop_sequential_p (struct loop* loop)
+{
+    return !parallel_p(loop);
+}
+
+static struct
+{
+  /* The number of loops fused. */
+  int fused;
+
+  /* The number of basic blocks merged during the cleanup pass */
+  int merged;
+
+} fusion_stats;
+
+#define EXTERNAL_STATS
+
+/* Print a message on the console if external stats are activated 
+ * and on the dump file if logging is activated. */
+
+static inline void
+print_stats (const char* message)
+{
+    if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+        fprintf (dump_file, message);
+        fprintf (dump_file, "\n");
+    }
+
+#ifdef EXTERNAL_STATS
+    printf ("STAT: ");
+    printf (message);
+    printf ("\n");
+#endif
+}
+
+/* Print a debug message if logging is enabled */
+
+static void
+print (const char* message)
+{
+    if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+        fprintf (dump_file, message);
+    }
+}
+
+/* 
+ * Print the current function to to the dump file 
+ * if logging is enabled. 
+ */
+
+static void 
+full_debug (const char* state)
+{
+    if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+        fprintf (dump_file, state);
+        dump_function_to_file (current_function_decl, dump_file, dump_flags);
+    }
+}
+
+/* Return the last BB (last in the instruction stream) */
+
+static basic_block 
+get_last_bb (struct loop *loop)
+{
+    basic_block header = loop->header;
+    basic_block latch = loop->latch;
+
+    if (header->next_bb == latch)
+    {
+       return latch; 
+    } 
+    else 
+    {
+        return header;
+    }
+}
+
+/* Return the first BB (first in the instruction stream) */
+
+static basic_block 
+get_first_bb (struct loop *loop)
+{
+    basic_block header = loop->header;
+    basic_block latch = loop->latch;
+
+    if (header->next_bb == latch)
+    {
+       return header; 
+    } 
+    else 
+    {
+        return latch;
+    }
+}
+
+/* Return the number of basic blocks between the two loops */
+
+static unsigned int
+distance_between_loops (struct loop *loop_first, struct loop *loop_next)
+{
+    //Some loops appears to have their latch first, so taking latch and header
+    //is not enough to determine the distance
+    basic_block current = get_last_bb (loop_first);
+    basic_block header_next = get_first_bb (loop_next);
+
+    unsigned int distance = 0;
+
+    while (current->next_bb != header_next)
+    {
+        ++distance;
+        current = current->next_bb;
+    }
+
+    return distance;
+}
+
+/* 
+ * Return the basic block between the two loops. 
+ * Assumes that the distance between the loops is 1. 
+ */
+
+static basic_block
+basic_block_between (struct loop *loop_first, struct loop* loop_next)
+{
+    //Some loops appears to have their latch first, so taking latch and header
+    //is not enough to determine the distance
+    basic_block last_bb = get_last_bb (loop_first);
+
+    basic_block between_bb = last_bb->next_bb;
+
+    gcc_assert (between_bb->next_bb == get_first_bb (loop_next));
+
+    return between_bb;
+}
+
+/* Return the induction variable SSA name for this loop */
+
+static tree 
+get_ssa_name_iv (struct loop* loop)
+{
+    tree ssa_iv_name = NULL_TREE;
+
+    gimple_stmt_iterator gsi;
+    for (gsi = gsi_start_bb (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))
+    {
+        gimple stmt = gsi_stmt (gsi);
+
+        if (gimple_code (stmt) == GIMPLE_COND)
+        {
+            tree lhs = gimple_cond_lhs (stmt);
+            tree rhs = gimple_cond_rhs (stmt);
+
+            if (TREE_CODE (lhs) == SSA_NAME)
+            {
+                ssa_iv_name = lhs;
+            }
+            else if (TREE_CODE (rhs) == SSA_NAME)
+            {
+                ssa_iv_name = rhs;
+            } 
+        }
+    }
+
+    gcc_assert (ssa_iv_name != NULL_TREE);
+
+    return ssa_iv_name;
+}
+
+/* Return the PHI Node for the given SSA name in the given loop */
+
+static tree 
+get_phi_var_for_iv(struct loop *loop, tree ssa_iv_name)
+{
+    gimple_stmt_iterator gsi;
+    for (gsi = gsi_start_phis (loop->header); 
+            !gsi_end_p (gsi); gsi_next (&gsi))
+    {
+        gimple phi = gsi_stmt (gsi);
+        
+        if (SSA_NAME_VAR (gimple_phi_result (phi)) == SSA_NAME_VAR (ssa_iv_name))
+        {
+            return gimple_phi_result (phi);
+        }
+    }
+
+    return NULL_TREE;
+}
+
+/* 
+ * This function fuses two loops together 
+ *
+ * The two functions have to be mergeable and mergeable together 
+ * before this function is called. 
+ */
+
+static void
+fuse_loops (struct loop* loop_first, struct loop* loop_next)
+{
+    if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+        fprintf (dump_file, "Fusion of A=%d and B=%d\n", 
+                loop_first->num, loop_next->num);
+        full_debug ("Before fusion\n");
+    }
+
+    /* 1. Replace the induction variable */
+
+    tree ssa_iv_name_first = get_ssa_name_iv (loop_first);
+    tree ssa_iv_name_next = get_ssa_name_iv (loop_next);
+    
+    tree use = get_phi_var_for_iv (loop_first, ssa_iv_name_first);
+    tree def = get_phi_var_for_iv (loop_next, ssa_iv_name_next);
+    
+    //Normally guaranteed by the conditions before fusing
+    gcc_assert (use != NULL_TREE);
+    gcc_assert (def != NULL_TREE);
+    
+    replace_uses_by (def, use);
+    
+    full_debug ("After IV replacing\n");
+
+    /* 2. Transfer other PHI nodes */
+
+    edge old_entry_edge = loop_preheader_edge (loop_next);
+    edge old_latch_edge = loop_latch_edge (loop_next);
+    
+    edge new_entry_edge = loop_preheader_edge (loop_first);
+    edge new_latch_edge = loop_latch_edge (loop_first);
+    
+    gimple_stmt_iterator gsi;
+    for (gsi = gsi_start_phis (loop_next->header); !gsi_end_p (gsi); )
+    {
+        gimple phi_orig = gsi_stmt (gsi);
+        tree result = gimple_phi_result ( phi_orig);
+        
+        if (SSA_NAME_VAR (result) != SSA_NAME_VAR (ssa_iv_name_next))
+        {
+            print ("Found a PHI node to copy \n");
+
+            gimple phi_new = create_phi_node (result, loop_first->header);
+        
+            tree def;
+            source_location locus;
+
+            /* Copy the first PHI arg (coming from entry) */
+            def = PHI_ARG_DEF_FROM_EDGE (phi_orig, old_entry_edge);
+            locus = gimple_phi_arg_location_from_edge (phi_orig, old_entry_edge);
+            add_phi_arg (phi_new, def, new_entry_edge, locus);
+            
+            /* Copy the second PHI arg (coming from the latch) */
+            def = PHI_ARG_DEF_FROM_EDGE (phi_orig, old_latch_edge);
+            locus = gimple_phi_arg_location_from_edge (phi_orig, old_latch_edge);
+            add_phi_arg (phi_new, def, new_latch_edge, locus);
+
+            //We do not want the SSA name to be released
+            remove_phi_node (&gsi, false);
+        } 
+        else 
+        {
+            //The SSA name can be released
+            remove_phi_node (&gsi, true);
+        }
+    }
+    
+    full_debug ("After transfer of PHI nodes\n");
+
+    /* 3. Transfer all the statements */
+    
+    gimple_stmt_iterator gsi_first_last = gsi_last_bb (loop_first->header);
+    gsi_prev (&gsi_first_last);
+
+    for (gsi = gsi_start_bb (loop_next->header); !gsi_end_p (gsi);)
+    {
+        gimple stmt = gsi_stmt (gsi);
+
+        if (gimple_code(stmt) != GIMPLE_COND)
+        {
+            update_stmt (stmt);
+            gsi_move_before (&gsi, &gsi_first_last);
+            update_stmt (stmt);
+        }
+        else
+        {
+            gsi_next (&gsi);
+        }
+    }
+    
+    full_debug ("After transfer of statements\n");
+
+    /* 5. Delete the loop A */
+    
+    //Save them before loop gets deleted
+    basic_block between_bb = basic_block_between (loop_first, loop_next);
+    basic_block header_next = loop_next->header;
+    basic_block latch_next = loop_next->latch;
+    basic_block next_bb = get_last_bb (loop_next)->next_bb;
+    
+    //Move header_next and latch_next in the outer loop
+    remove_bb_from_loops (header_next);
+    add_bb_to_loop (header_next, loop_outer (loop_first));
+    
+    remove_bb_from_loops (latch_next);
+    add_bb_to_loop (latch_next, loop_outer (loop_first));
+    
+    delete_loop(loop_next);
+        
+    delete_basic_block(latch_next);
+        
+    full_debug ("After removing the loop\n");
+
+    /* 6. Fix edges */
+
+    //Fix the type of the edge
+    single_succ_edge (header_next)->flags |= EDGE_FALLTHRU;
+    single_succ_edge (header_next)->flags &= ~EDGE_TRUE_VALUE;
+    single_succ_edge (header_next)->flags &= ~EDGE_FALSE_VALUE;
+    
+    //Remove the condition from the old loop header
+    for (gsi = gsi_start_bb (header_next); !gsi_end_p (gsi);)
+    {
+        gimple stmt = gsi_stmt (gsi);
+
+        if (gimple_code (stmt) == GIMPLE_COND)
+        {
+            gsi_remove (&gsi, true);
+        }
+        else
+        {
+            gsi_next (&gsi);
+        }
+    }
+    
+    full_debug ("After fixing the edges \n");
+
+    /* 7. Clean the basic blocks */
+
+    //Remove the between block if possible
+    if (gimple_seq_empty_p (phi_nodes (between_bb)) 
+            && gimple_seq_empty_p (bb_seq (between_bb)))
+    {
+        redirect_edge_and_branch (single_pred_edge (between_bb), header_next);
+
+        delete_basic_block (between_bb);
+    } 
+    else 
+    {
+        set_immediate_dominator (CDI_DOMINATORS, between_bb, 
+                recompute_dominator (CDI_DOMINATORS, between_bb));
+    }
+    
+    full_debug ("After cleaning basic blocks\n");
+
+    /* 7. Update SSA */
+
+    update_ssa (TODO_update_ssa);
+
+    /* 8. Update dominators */
+    
+    set_immediate_dominator (CDI_DOMINATORS, loop_first->header, 
+            recompute_dominator (CDI_DOMINATORS, loop_first->header));
+    set_immediate_dominator (CDI_DOMINATORS, loop_first->latch, 
+            recompute_dominator (CDI_DOMINATORS, loop_first->latch));
+    set_immediate_dominator (CDI_DOMINATORS, next_bb, 
+            recompute_dominator (CDI_DOMINATORS, next_bb));
+    set_immediate_dominator (CDI_DOMINATORS, header_next, 
+            recompute_dominator (CDI_DOMINATORS, header_next));
+
+    /* 9. Fix the profile information */
+
+    //TODO Restore the profile information
+    
+    full_debug ("After fusion\n");
+
+    print_stats ("Loop Fused");
+    ++fusion_stats.fused;
+}
+
+/* Indicates if the specified basic block can be merged */
+
+static bool
+dirty (basic_block bb)
+{
+    if (gimple_seq_empty_p (bb_seq (bb)))
+    {
+        return single_succ_p (bb) && single_pred_p (bb);
+    }
+
+    return false;
+}
+
+/* Tries to find basic blocks to merge */
+
+static void
+cleanup ()
+{
+    basic_block bb;
+    
+    FOR_EACH_BB(bb)
+    {
+        if (dirty(bb))
+        {
+            basic_block bb_next = bb->next_bb;
+
+            if (bb_next && dirty (bb_next))
+            {
+                //They have to fall through the instruction stream
+                if (single_succ_edge (bb)->dest == bb_next)
+                {
+                    merge_blocks (bb, bb_next);
+                    
+                    print_stats ("Block Merged");
+                    ++fusion_stats.merged;
+                }
+            }
+        }
+    }
+}
+
+/* 
+ * Returns true if the access functions are equivalent, 
+ * the induction variable may vary. 
+ */
+
+static bool
+are_equivalent_functions (const_tree chrec0, const_tree chrec1)
+{
+    if (chrec0 == NULL_TREE || chrec1 == NULL_TREE 
+            || TREE_CODE (chrec0) != TREE_CODE (chrec1))
+    {
+        return false;
+    }
+
+    if (chrec0 == chrec1)
+    {
+        return true;
+    }
+
+    switch (TREE_CODE (chrec0))
+    {
+        case INTEGER_CST:
+            return operand_equal_p (chrec0, chrec1, 0);
+
+        case POLYNOMIAL_CHREC:
+            return eq_evolutions_p (CHREC_LEFT (chrec0), CHREC_LEFT (chrec1))
+                && eq_evolutions_p (CHREC_RIGHT (chrec0), CHREC_RIGHT (chrec1));
+
+        case PLUS_EXPR:
+        case MULT_EXPR:
+        case MINUS_EXPR:
+        case POINTER_PLUS_EXPR:
+            return eq_evolutions_p (TREE_OPERAND (chrec0, 0), TREE_OPERAND (chrec1, 0))
+                && eq_evolutions_p (TREE_OPERAND (chrec0, 1), TREE_OPERAND (chrec1, 1));
+
+        default:
+            return false;
+    }
+}
+
+/* 
+ * Returns true if both data references have equivalent access function, 
+ * the induction variable may change. 
+ */
+
+static bool
+are_equivalent (data_reference_p a, data_reference_p b)
+{
+    unsigned int i;
+
+    /* The references are exactly the same.  */
+    if (operand_equal_p (DR_REF (a), DR_REF (b), 0))
+    {
+        return true;
+    }
+
+    if (!same_data_refs_base_objects (a, b))
+    {
+        return false;
+    }
+
+    for (i = 0; i < DR_NUM_DIMENSIONS (a); i++)
+    {
+        if (!are_equivalent_functions (DR_ACCESS_FN (a, i), DR_ACCESS_FN (b, i)))
+        {
+            return false;
+        }
+    }
+
+    //TODO Verify the var of each data reference is the induction variable
+
+    return true;
+}
+
+static bool
+check_chrec_dont_know (VEC (ddr_p, heap) *relations)
+{
+    ddr_p ddr;
+    unsigned int i;
+
+    FOR_EACH_VEC_ELT (ddr_p, relations, i, ddr)
+    {
+        if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)
+        {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+/* Returns true if loops are independent. */
+
+static bool
+are_independent (struct loop *loop_first, struct loop *loop_next)
+{
+    VEC (data_reference_p, heap) *datarefs_next = 
+        VEC_alloc (data_reference_p, heap, 10);
+    VEC (data_reference_p, heap) *datarefs_first = 
+        VEC_alloc (data_reference_p, heap, 10);
+
+    VEC (ddr_p, heap) *dependence_relations_next = 
+        VEC_alloc (ddr_p, heap, 10 * 10);
+    VEC (ddr_p, heap) *dependence_relations_first = 
+        VEC_alloc (ddr_p, heap, 10 * 10);
+
+    VEC (loop_p, heap) *loop_nest_next = VEC_alloc (loop_p, heap, 3);
+    VEC (loop_p, heap) *loop_nest_first = VEC_alloc (loop_p, heap, 3);
+
+    bool success = true;
+    success &= compute_data_dependences_for_loop (loop_first, true, &loop_nest_first, 
+            &datarefs_first, &dependence_relations_first);
+    success &= compute_data_dependences_for_loop (loop_next, true, &loop_nest_next, 
+            &datarefs_next, &dependence_relations_next); 
+
+    //If the data dependence does not success, we consider the loops as dependent
+    bool ret = false;
+
+    if (!success)
+    {
+        print_stats ("Data dependence analysis failed");
+    }
+    else
+    {
+        //If no dependences are found later, the loops are not dependent
+        ret = true;
+
+        data_reference_p ref_first;
+        data_reference_p ref_next;
+        unsigned int i;
+        unsigned int j;
+
+        //Dump data references
+        if (dump_file && (dump_flags & TDF_DETAILS))
+        {
+            fprintf (dump_file, "Print data reference of A\n");
+            FOR_EACH_VEC_ELT (data_reference_p, datarefs_first, i, ref_first)
+            {
+                if (!ref_first || !DR_STMT (ref_first))
+                {
+                    fprintf (dump_file, "Null data reference\n");
+                } 
+                else 
+                {
+                    dump_data_reference (dump_file, ref_first);
+                }
+            }
+
+            fprintf (dump_file, "Print data reference of B\n");
+            FOR_EACH_VEC_ELT (data_reference_p, datarefs_next, j, ref_next)
+            {
+                if (!ref_next || !DR_STMT (ref_next))
+                {
+                    fprintf (dump_file, "Null data reference\n");
+                } 
+                else 
+                {
+                    dump_data_reference (dump_file, ref_next);
+                }
+            }
+
+            fprintf (dump_file, "Print data dependence relations of A\n");
+            dump_data_dependence_relations (dump_file, dependence_relations_first);
+            
+            fprintf (dump_file, "Print data dependence relations of B\n");
+            dump_data_dependence_relations (dump_file, dependence_relations_next);
+        }
+        
+        if (!check_chrec_dont_know (dependence_relations_first))
+        {
+            print_stats ("chrec_dont_know");
+            print ("Loops are dependent due to a chrec_dont_know in A\n");
+            ret = false;
+        }
+        else if (!check_chrec_dont_know (dependence_relations_next))
+        {
+            print_stats ("chrec_dont_know");
+            print ("Loops are dependent due to a chrec_dont_know in B\n");
+            ret = false;
+        }
+
+        //Only if there are no "don't know" data dependence relations
+        if (ret)
+        {
+            //Consider each pair of dependences between the loops
+            FOR_EACH_VEC_ELT (data_reference_p, datarefs_first, i, ref_first)
+            {
+                //TODO Find what to do with these "NULL" references
+                if (!ref_first || !DR_STMT (ref_first))
+                {
+                    print_stats ("NULL reference");
+                    print ("Unresolved data reference in A\n");
+                    ret = false;
+                    break;
+                }
+
+                FOR_EACH_VEC_ELT (data_reference_p, datarefs_next, j, ref_next)
+                {
+                    //TODO Find what to do with these "NULL" references
+                    if (!ref_next || !DR_STMT (ref_next))
+                    {
+                        print_stats ("NULL reference");
+                        print ("Unresolved data reference in B\n");
+                        ret = false;
+                        break;
+                    }
+
+                    if (same_data_refs_base_objects (ref_first, ref_next))
+                    {
+                        if (DR_IS_READ (ref_first) && DR_IS_READ (ref_next))
+                        {
+                            print ("Found an input-dependence\n");
+                            //Input reference can be ignored
+                        }
+                        else 
+                        {
+                            if (DR_IS_WRITE (ref_first) && DR_IS_WRITE (ref_next))
+                            {
+                                print ("Found an output-dependence\n");
+
+                                if (!are_equivalent (ref_first, ref_next))
+                                {
+                                    print_stats ("blocking output-dependence");
+                                    print ("An output-dependence is blocking\n");
+                                    ret = false;
+                                }
+                            } 
+                            else if (DR_IS_READ (ref_first) && DR_IS_WRITE (ref_next))
+                            {
+                                print ("Found an anti-dependence\n");
+
+                                if (!are_equivalent (ref_first, ref_next))
+                                {
+                                    print_stats ("blocking anti-dependence");
+                                    print ("An anti-dependence is blocking\n");
+                                    ret = false;
+                                }
+                            } 
+                            else if (DR_IS_WRITE (ref_first) && DR_IS_READ (ref_next))
+                            {
+                                print ("Found a true-dependence\n");
+
+                                if (!are_equivalent (ref_first, ref_next))
+                                {
+                                    print_stats ("blocking true-dependence");
+                                    print ("A true-dependence is blocking\n");
+                                    ret = false;
+                                }
+                            }
+                        }
+                    }
+                }
+
+                if (!ret)
+                {
+                    break;
+                }
+            }
+        }
+    }
+
+    free_dependence_relations (dependence_relations_next);
+    free_dependence_relations (dependence_relations_first);
+
+    free_data_refs (datarefs_next);
+    free_data_refs (datarefs_first);
+
+    VEC_free (loop_p, heap, loop_nest_next);
+    VEC_free (loop_p, heap, loop_nest_first);
+
+    return ret;
+}
+
+/* Return the index of the basic block in the instruction stream */
+
+static unsigned int
+bb_stream_index (basic_block block)
+{
+    unsigned int index = 0;
+
+    basic_block bb;
+    FOR_EACH_BB (bb)
+    {
+        if (bb == block)
+        {
+            break;
+        }
+
+        ++index;
+    }
+
+    return index;
+}
+
+/* Verify if this loop is supported by the merging algorithm */
+
+static bool 
+loop_is_mergeable (struct loop* loop)
+{
+    //The algorithm only supports loops with a header and a latch
+    if (loop->num_nodes > 2)
+    {
+        print_stats ("LIMITATION: Too many blocks");
+        return false;
+    }
+
+    //The algorithm will fail on loop with more than one exit
+    if (!single_exit (loop))
+    {
+        print_stats ("LIMITATION: Not single exit");
+        return false; 
+    }
+
+    //It is necessary to know the number of times a loop will iterate
+    if (!loop->any_estimate || !loop->any_upper_bound)
+    {
+        print_stats ("CONDITION: No estimate");
+        return false;
+    }
+    
+    //It is necessary to have a precise estimate
+    if (double_int_ucmp (loop->nb_iterations_estimate, loop->nb_iterations_upper_bound) != 0)
+    {
+        print_stats ("CONDITION: No precise estimate");
+        return false;
+    }
+
+    //The latch must be empty because the statements 
+    //are not transferred to the other latch
+    if (!gimple_seq_empty_p (bb_seq (loop->latch)) 
+           || !gimple_seq_empty_p (phi_nodes (loop->latch)))
+    {
+        print_stats ("LIMITATION: Latch not empty");
+        return false;
+    }
+    
+    tree ssa_iv_name = get_ssa_name_iv (loop);
+
+    //The Induction Variable is not of integer type
+    if (TREE_CODE (TREE_TYPE (ssa_iv_name)) != INTEGER_TYPE)
+    {
+        print_stats ("LIMITATION: IV not integer");
+        return false;
+    }
+
+    //With a NULL_TREE, we are not able to find the correct PHI node
+    if (SSA_NAME_VAR (ssa_iv_name) == NULL_TREE)
+    {
+        print_stats ("LIMITATION: SSA NAME NULL TREE");
+        return false;
+    }
+
+    tree phi_iv = get_phi_var_for_iv (loop, ssa_iv_name);
+
+    //The PHI node is necessary for renaming
+    if (phi_iv == NULL_TREE)
+    {
+        print_stats ("LIMITATION: No PHI");
+        return false;
+    }
+    
+    basic_block header = loop->header;
+    basic_block latch = loop->latch;
+
+    //The header and the latch should be sibling in the instruction stream
+    if (!(header->next_bb == latch || latch->next_bb == header))
+    {
+        print_stats ("LIMITATION: Latch Header not sibling");
+        return false;
+    }
+
+    return true;
+}
+
+/* Return true if the loops can be fused. Both loops have to be mergeable. */
+
+static bool
+loops_are_mergeable (struct loop *loop_first, struct loop *loop_next)
+{
+    //Both loop should iterate the same number of times
+    if (double_int_ucmp (loop_next->nb_iterations_estimate, loop_first->nb_iterations_estimate) != 0)
+    {
+        print_stats ("CONDITION: The loop does not have the same estimate");
+
+        return false;
+    }
+
+    //Only support loops with only one basic block between them
+    unsigned int distance = distance_between_loops (loop_first, loop_next);
+    if (distance != 1)
+    {
+        print_stats ("LIMITATION: The distance is too high");
+
+        return false;
+    }
+
+    basic_block between_bb = basic_block_between (loop_first, loop_next);
+
+    //The two loops must be always executed together
+    if (!single_succ_p (between_bb) || !single_pred_p (between_bb))
+    {
+        print_stats ("CONDITION: The between block can be executed alone");
+
+        return false;
+    }
+
+    //Only empty block between A and B are supported
+    if (!gimple_seq_empty_p( bb_seq( between_bb)))
+    {
+        print_stats ("LIMITATION: Too many statements in the between block");
+
+        return false;
+    }
+
+    //The between block can contains PHI nodes 
+    //if they are not used in the second loop
+    gimple_stmt_iterator gsi;
+    for (gsi = gsi_start_phis (between_bb); !gsi_end_p (gsi); gsi_next (&gsi))
+    {
+        gimple phi = gsi_stmt (gsi);
+        tree ssa_name = gimple_phi_result (phi);
+       
+        use_operand_p imm_use_p;
+        imm_use_iterator iterator;
+
+        FOR_EACH_IMM_USE_FAST (imm_use_p, iterator, ssa_name)
+        {
+            gimple use_stmt = USE_STMT (imm_use_p);
+            basic_block use_block = gimple_bb (use_stmt);
+
+            if (use_block == loop_next->header || use_block == loop_next->latch)
+            {
+                print_stats ("LIMITATION: A PHI node in between block is used");
+
+                return false;
+            }
+        }
+    }
+    
+    tree ssa_iv_name_first = get_ssa_name_iv (loop_first);
+    tree ssa_iv_name_next = get_ssa_name_iv (loop_next);
+
+    tree type_iv_first = TREE_TYPE (ssa_iv_name_first);
+    tree type_iv_next = TREE_TYPE (ssa_iv_name_next);
+
+    //The induction variables must be both signed or both unsigned
+    if ((TYPE_UNSIGNED (type_iv_first) && !TYPE_UNSIGNED (type_iv_next)) 
+            || (!TYPE_UNSIGNED (type_iv_first) && TYPE_UNSIGNED (type_iv_next)))
+    {
+        print_stats ("CONDITION: The induction variables does not have corresponding signedness");
+
+        return false;
+    }
+    
+    //The induction variables must of same precision
+    if (TYPE_PRECISION (type_iv_first) != TYPE_PRECISION (type_iv_next))
+    {
+        print_stats ("CONDITION: The induction variables does not have corresponding precision");
+
+        return false;
+    }
+
+    //The loops needs to be independent
+    if(!are_independent (loop_first, loop_next)){
+        print_stats ("CONDITION: The loops are not independent");
+
+        return false;
+    }
+
+    //The loops can be fused
+    return true;
+}
+
+/* Return the number of instructions in the loop header */
+
+static unsigned int
+size (struct loop *loop)
+{
+    unsigned int count = 0;
+
+    gimple_stmt_iterator gsi;
+    for (gsi = gsi_start_bb (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))
+    {
+        ++count;
+    }
+
+    return count;
+}
+
+/* Returns true if loops have a data reference in common on an array. */
+
+//TODO Certainly much better to reuse the previously computed 
+//data references rather than recomputing them
+
+static bool
+have_common_array_reference (struct loop *loop_first, struct loop *loop_next)
+{
+    VEC (data_reference_p, heap) *datarefs_next = 
+        VEC_alloc (data_reference_p, heap, 10);
+    VEC (data_reference_p, heap) *datarefs_first = 
+        VEC_alloc (data_reference_p, heap, 10);
+
+    VEC (ddr_p, heap) *dependence_relations_next = 
+        VEC_alloc (ddr_p, heap, 10 * 10);
+    VEC (ddr_p, heap) *dependence_relations_first = 
+        VEC_alloc (ddr_p, heap, 10 * 10);
+
+    VEC (loop_p, heap) *loop_nest_next = VEC_alloc (loop_p, heap, 3);
+    VEC (loop_p, heap) *loop_nest_first = VEC_alloc (loop_p, heap, 3);
+
+    compute_data_dependences_for_loop (loop_first, true, &loop_nest_first, 
+            &datarefs_first, &dependence_relations_first);
+    compute_data_dependences_for_loop (loop_next, true, &loop_nest_next, 
+            &datarefs_next, &dependence_relations_next); 
+
+    bool ret = false;
+
+    data_reference_p ref_first;
+    data_reference_p ref_next;
+    unsigned int i;
+    unsigned int j;
+
+    //Consider each pair of dependences between the loops
+    FOR_EACH_VEC_ELT (data_reference_p, datarefs_first, i, ref_first)
+    {
+        FOR_EACH_VEC_ELT (data_reference_p, datarefs_next, j, ref_next)
+        {
+            if (same_data_refs_base_objects (ref_first, ref_next))
+            {
+                //TODO Verify that it is an array
+
+                ret = true;
+                break;
+            }
+        }
+
+        if (ret)
+        {
+            break;
+        }
+    }
+
+    free_dependence_relations (dependence_relations_next);
+    free_dependence_relations (dependence_relations_first);
+
+    free_data_refs (datarefs_next);
+    free_data_refs (datarefs_first);
+
+    VEC_free (loop_p, heap, loop_nest_next);
+    VEC_free (loop_p, heap, loop_nest_first);
+
+    return ret;
+}
+
+/* 
+ * Return true if the two loops are interesting to merge, 
+ * otherwise return false.
+ */
+
+static bool
+loops_are_interesting_to_merge (struct loop *loop_first, struct loop *loop_next)
+{
+    if (flag_auto_profile)
+    {
+        long first_misses = 
+              loop_first->header->cache_misses
+            + loop_first->latch->cache_misses;
+        long next_misses = 
+              loop_next->header->cache_misses
+            + loop_next->latch->cache_misses;
+
+        if (first_misses > 200L && next_misses > 200L)
+        {
+            if (first_misses > next_misses)
+            {
+                return next_misses * 1.2 >= first_misses;
+            }
+            else 
+            {
+                return first_misses * 1.2 >= next_misses;
+            }
+        }
+
+        return false;
+    }
+    else 
+    {
+        //Do not create loops with big body
+        if (size (loop_first) + size (loop_next) > 50)
+        {
+            print_stats ("DECISION: Not interesting because too big");
+
+            return false;
+        }
+
+        double_int hundred = uhwi_to_double_int(100u);
+
+        //Fuse only loops that iterate enough times
+        if (double_int_ucmp (loop_first->nb_iterations_estimate, hundred) < 0)
+        {
+            struct loop *outer = loop_outer (loop_first);
+            if (!outer || double_int_ucmp (outer->nb_iterations_estimate, hundred) < 0)
+            {
+                print_stats ("DECISION: Not interesting because too small iterates");
+
+                return false;
+            }
+        }
+
+        //Only merge parallel/parallel or sequential/sequential loops 
+        //if auto parallelization is enabled
+        if (flag_tree_parallelize_loops > 1 
+                && ((parallel_p (loop_first) && loop_sequential_p (loop_next)) 
+                    || ( loop_sequential_p (loop_first) && parallel_p (loop_next))))
+        {
+            print_stats ("DECISION: Not interesting because of autopar");
+
+            return false;
+        }
+
+        //Try to predict cache misses
+        if ((!have_common_array_reference (loop_first, loop_next)))
+        {
+            print_stats ("DECISION: Not interesting because no common array reference");
+
+            return false;
+        }
+    }
+
+    return true;
+}
+
+/* Performs legal loops fusion in the current function.  */
+
+static unsigned int
+tree_loop_fusion (void)
+{
+    //If there are no loops, no need to go farther
+    if (!current_loops)
+    {
+        return 0;
+    }
+
+    //Initialize the stats
+    memset (&fusion_stats, 0, sizeof (fusion_stats));
+   
+    if (dump_file && (dump_flags & TDF_DETAILS))
+    {
+        fprintf (dump_file, "Start loop fusion pass\n");
+
+        flow_loops_dump (dump_file, NULL, 10);
+    }
+
+    struct loop *loop_first;
+    loop_iterator li;
+
+    //Consider only innermost loops, other cannot be merged with this strategy
+    FOR_EACH_LOOP (li, loop_first, LI_ONLY_INNERMOST)
+    {
+        //The algorithm cannot merge all loops
+        if (!loop_is_mergeable (loop_first))
+        {
+            print_stats ("Loop A not mergeable");
+
+            continue;
+        }
+
+        //Loop_first->next points to a loop in the same loop tree
+        if (loop_first->next)
+        {
+            struct loop *loop_next = loop_first->next;
+
+            gcc_assert (loop_outer (loop_first) == loop_outer (loop_next));
+
+            //The algorithm cannot merge all loops
+            if (!loop_is_mergeable (loop_next))
+            {
+                print_stats ("Loop B not mergeable");
+
+                continue;
+            }
+
+            unsigned int index_first = bb_stream_index (loop_first->header);
+            unsigned int index_next  = bb_stream_index (loop_next->header);
+
+            //Order them so that the first is before the next in the instruction stream
+            if (index_first > index_next)
+            {
+                struct loop* tmp = loop_next;
+                loop_next = loop_first;
+                loop_first = tmp;
+            }
+
+            if (dump_file && (dump_flags & TDF_DETAILS))
+            {
+                fprintf (dump_file, "Consider Loops %d and %d as candidates\n", 
+                        loop_first->num, loop_next->num);
+            }
+
+            //Verify that the loops can be merged together
+            if (!loops_are_mergeable (loop_first, loop_next))
+            {
+                print_stats ("Loops cannot be merged together");
+
+                continue;
+            }
+                
+            //Finally, if they are interesting to merge, merge them
+            if (loops_are_interesting_to_merge (loop_first, loop_next))
+            {
+                fuse_loops (loop_first, loop_next);
+
+                //The cleanup remove empty basic blocks 
+                //to make further loop fusion possible
+                cleanup();
+            }
+            else 
+            {
+                print_stats ("Loops are not interesting to merge");
+            }
+        }
+    }
+    
+    //Update and verify the function is loops were fused
+    if (fusion_stats.fused > 0)
+    {
+        //The merging strategy does not take virtual operands into account
+        //mark_virtual_operands_for_renaming (cfun);
+
+        //Make sure the function is transformed in LCSSA
+        rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);
+
+        //Update if necessary
+        update_ssa (TODO_update_ssa);
+
+        //Activate verification of the whole function
+        #ifdef ENABLE_CHECKING
+            verify_loop_structure ();
+            verify_gimple_in_cfg (cfun);
+            verify_ssa (true);
+        #endif
+    }
+  
+    //Add events for this pass 
+    statistics_counter_event (cfun, "Loop Fused", fusion_stats.fused);
+    statistics_counter_event (cfun, "Basic Blocks Merged", fusion_stats.merged);
+
+    return 0;
+}
+
+static bool
+gate_tree_loop_fusion (void)
+{
+    return flag_tree_loop_fusion != 0;
+}
+
+struct gimple_opt_pass pass_loop_fusion =
+{
+    {
+        GIMPLE_PASS, 
+        "lfusion",                        /* name */
+        gate_tree_loop_fusion,            /* gate */
+        tree_loop_fusion,                 /* execute */
+        NULL,                             /* sub */
+        NULL,                             /* next */
+        0,                                /* static_pass_number */
+        TV_TREE_LOOP_FUSION,              /* tv_id */
+        PROP_cfg | PROP_ssa,              /* properties_required */
+        0,                                /* properties_provided */
+        0,                                /* properties_destroyed */
+        0,                                /* todo_flags_start */
+        TODO_update_ssa | TODO_verify_ssa /* todo_flags_finish */ 
+    }
+};

Index: gcc/opts.c
===================================================================
--- gcc/opts.c	(revision 194505)
+++ gcc/opts.c	(working copy)
@@ -486,6 +486,7 @@
     { OPT_LEVELS_2_PLUS, OPT_falign_labels, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_falign_functions, NULL, 1 },
     { OPT_LEVELS_2_PLUS, OPT_ftree_tail_merge, NULL, 1 },
+    { OPT_LEVELS_2_PLUS, OPT_ftree_loop_fusion, NULL, 1 },
     { OPT_LEVELS_2_PLUS_SPEED_ONLY, OPT_foptimize_strlen, NULL, 1 },
 
     /* -O3 optimizations.  */
Index: gcc/timevar.def
===================================================================
--- gcc/timevar.def	(revision 194505)
+++ gcc/timevar.def	(working copy)
@@ -171,6 +171,7 @@
 DEFTIMEVAR (TV_GRAPHITE_DATA_DEPS    , "Graphite data dep analysis")
 DEFTIMEVAR (TV_GRAPHITE_CODE_GEN     , "Graphite code generation")
 DEFTIMEVAR (TV_TREE_LINEAR_TRANSFORM , "tree loop linear")
+DEFTIMEVAR (TV_TREE_LOOP_FUSION      , "tree loop fusion")
 DEFTIMEVAR (TV_TREE_LOOP_DISTRIBUTION, "tree loop distribution")
 DEFTIMEVAR (TV_CHECK_DATA_DEPS       , "tree check data dependences")
 DEFTIMEVAR (TV_TREE_PREFETCH	     , "tree prefetching")
Index: gcc/tree-parloops.c
===================================================================
--- gcc/tree-parloops.c	(revision 192697)
+++ gcc/tree-parloops.c	(working copy)
@@ -364,7 +364,7 @@
    are independent on each other (that is, if we can execute them
    in parallel).  */
 
-static bool
+bool
 loop_parallel_p (struct loop *loop, struct obstack * parloop_obstack)
 {
   VEC (loop_p, heap) *loop_nest;
Index: gcc/common.opt
===================================================================
--- gcc/common.opt	(revision 192697)
+++ gcc/common.opt	(working copy)
@@ -2055,6 +2055,10 @@
 Common Report Var(flag_optimize_strlen) Optimization
 Enable string length optimizations on trees
 
+ftree-loop-fusion
+Common Report Var(flag_tree_loop_fusion) Optimization
+Enable loop fusion on trees
+
 ftree-loop-distribution
 Common Report Var(flag_tree_loop_distribution) Optimization
 Enable loop distribution on trees
Index: gcc/Makefile.in
===================================================================
--- gcc/Makefile.in	(revision 194505)
+++ gcc/Makefile.in	(working copy)
@@ -1379,6 +1379,7 @@
 	tree-into-ssa.o \
 	tree-iterator.o \
 	tree-loop-distribution.o \
+	tree-loop-fusion.o \
 	tree-nested.o \
 	tree-nomudflap.o \
 	tree-nrv.o \
@@ -2694,6 +2695,11 @@
    $(TM_H) $(GGC_H) $(TREE_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) \
    $(CFGLOOP_H) $(TREE_PASS_H) $(TREE_VECTORIZER_H) $(TIMEVAR_H) \
    tree-pretty-print.h
+tree-loop-fusion.o: tree-loop-fusion.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+   $(TM_H) $(GGC_H) $(OPTABS_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) \
+   $(DIAGNOSTIC_H) $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) \
+   tree-pass.h $(TREE_DATA_REF_H) $(SCEV_H) $(EXPR_H) \
+   $(TARGET_H) tree-chrec.h tree-vectorizer.h
 tree-loop-distribution.o: tree-loop-distribution.c $(CONFIG_H) $(SYSTEM_H) \
    coretypes.h $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) $(TREE_PASS_H)
 tree-parloops.o: tree-parloops.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
Index: gcc/passes.c
===================================================================
--- gcc/passes.c	(revision 192697)
+++ gcc/passes.c	(working copy)
@@ -1450,6 +1450,7 @@
 	  NEXT_PASS (pass_scev_cprop);
 	  NEXT_PASS (pass_record_bounds);
 	  NEXT_PASS (pass_check_data_deps);
+     NEXT_PASS (pass_loop_fusion);
 	  NEXT_PASS (pass_loop_distribution);
 	  NEXT_PASS (pass_copy_prop);
 	  NEXT_PASS (pass_graphite);
